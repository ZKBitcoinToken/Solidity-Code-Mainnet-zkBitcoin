{
  "language": "Solidity",
  "sources": {
    "contracts/paymasters/zkBitcoin_Paymaster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n//Paymaster for zkBitcoin contract.  Paymaster will auto launch new contract for mining.   Paymaster pays all transaction fees so long as the minted zkBitcoin is less than transaction cost!\n    \npragma solidity ^0.8.0;\n\n//import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\n\n\n\ninterface IERC721 {\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\ninterface IERC1155 {\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n}\n\ncontract PaymasterZKBitcoin_Pool {\n\taddress public allowedToken;\n\taddress public Paymaster;\n\taddress public AddressToUse;\n\tuint public NumberofMints = 0;\n    constructor(address zkBTCToken, address _Paymaster, address _AddressToUse) {\n    \tallowedToken = zkBTCToken;\n    \tPaymaster = _Paymaster;\n    \tAddressToUse = _AddressToUse;\n    }\n    \n    \n\n\tfunction MultiMint_Paymaster(uint[] memory nonces, uint nonceLength, uint requiredZKBTC) public returns (bool){\n\t\tuint nonceLength = nonceLength;\n\t\t // Create a new array with the desired length\n\t\tuint[] memory firstNonces = new uint[](nonceLength);\n\t\t    \n\t\t// Copy the first 'newLength' elements from 'nonces' to 'firstTenNonces'\n\t\tfor (uint i = 0; i < nonceLength; i++) {\n\t\t\tfirstNonces[i] = nonces[i];\n\t\t}\t\t\n\t\t\n\t\t/*\n\t\tfor(uint x=0; x< nonceLength; x++){\n\t\t zkBitcoin2(allowedToken).mintTo(nonces[x], address(this));\n\t\t \n\t\t\n\t\t}*/\n\t\tzkBitcoin2(allowedToken).multiMint_SameAddress(address(this), firstNonces);\n\t\tuint totReward = nonceLength * zkBitcoin2(allowedToken).getMiningReward();\n\t\trequire(requiredZKBTC <= totReward, \"Must MUST MUST be profitable to mint.\");\n\t\trequire(nonceLength * zkBitcoin2(allowedToken).getMiningReward() <= IERC20(allowedToken).balanceOf(address(this)),\"Problem with multiMint seems not all your answers were correct.\");\n\t\t//so we only send what we minted with paymaster, no need to overpay and send all the tokens.\n\t\tIERC20(allowedToken).transfer(Paymaster, totReward);\n\t\tNumberofMints = NumberofMints + nonceLength;\n\t}\n\t\n\t//This is the non-Paymaster Mint method, use this to mint your tokens without a Paymaster to your address!\n\tfunction PoolContract_Mint_No_Paymaster(uint[] memory nonces) public returns (bool){\n\t\t\n\t\tzkBitcoin2(allowedToken).multiMint_SameAddress(address(this), nonces);\n\t\tIERC20(allowedToken).transfer(AddressToUse, IERC20(allowedToken).balanceOf(address(this)));\n\t}\n\t\n\t\n\t\n\t//Only for use to estimate gas because MultiMint_Paymaster fails in estimateGas so we use this function instead below.\n\tfunction estimateGas_Paymaster(uint[] memory nonces, uint nonceLength) public returns (bool){\n\t\t // Create a new array with the desired length\n\t\tuint[] memory firstNonces = new uint[](nonceLength);\n\t\t    \n\t\t// Copy the first 'newLength' elements from 'nonces' to 'firstTenNonces'\n\t\tfor (uint i = 0; i < nonceLength; i++) {\n\t\t\tfirstNonces[i] = nonces[i];\n\t\t}\t\t\n\t\t\n\t\t/*\n\t\tfor(uint x=0; x< nonceLength; x++){\n\t\t zkBitcoin2(allowedToken).mintTo(nonces[x], address(this));\n\t\t \n\t\t\n\t\t}*/\n\t\tzkBitcoin2(allowedToken).multiMint_SameAddress(address(this), firstNonces);\n\t\tIERC20(allowedToken).transfer(Paymaster, IERC20(allowedToken).balanceOf(address(this)));\n\t}\n\n\n\t // Function to send ETH\n    function withdrawETH(uint _amount) public {\n        require(address(this).balance >= _amount, \"Insufficient balance in contract\");\n        // Transfer ETH\n        (bool sent, ) = AddressToUse.call{value: _amount}(\"\");\n        require(sent, \"Failed to send ETH\");\n    }\n    \n    // Function to withdraw ERC20 tokens\n    function withdrawERC20(address token, uint256 amount) public {\n        require(IERC20(token).transfer(AddressToUse, amount), \"Transfer failed\");\n    }\n\n    // Function to withdraw ERC721 tokens\n    function withdrawERC721(address token, uint256 tokenId) public {\n        IERC721(token).transferFrom(address(this), AddressToUse, tokenId);\n    }\n\n    // Function to withdraw ERC1155 tokens\n    function withdrawERC1155(address token, uint256 tokenId, uint256 amount, bytes calldata data) public {\n        IERC1155(token).safeTransferFrom(address(this), AddressToUse, tokenId, amount, data);\n    }\n    \n    \n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//import {IPaymaster, ExecutionResult, PAYMASTER_VALIDATION_SUCCESS_MAGIC} from \"@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IPaymaster.sol\";\n\n\n//import \"../libraries/TransactionHelper.sol\";\n\n\n//import \"../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\n//import \"../IERC20.sol\";\n//import \"../extensions/IERC20Permit.sol\";\n\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n//import \"../../../utils/Address.sol\";\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                0,\n                \"Address: low-level call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage)\n        private\n        pure\n    {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(\n                oldAllowance >= value,\n                \"SafeERC20: decreased allowance below zero\"\n            );\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(\n            nonceAfter == nonceBefore + 1,\n            \"SafeERC20: permit did not succeed\"\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\n\n\n//import \"../interfaces/IPaymasterFlow.sol\";\n/**\n * @author Matter Labs\n * @dev The interface that is used for encoding/decoding of\n * different types of paymaster flows.\n * @notice This is NOT an interface to be implementated\n * by contracts. It is just used for encoding.\n */\ninterface IPaymasterFlow {\n    function general(bytes calldata input) external;\n\n    function approvalBased(address _token, uint256 _minAllowance, bytes calldata _innerInput) external;\n}\n\n\n\n\n//import \"../interfaces/IContractDeployer.sol\";\n\n\n\n\ninterface IContractDeployer {\n    /// @notice Defines the version of the account abstraction protocol\n    /// that a contract claims to follow.\n    /// - `None` means that the account is just a contract and it should never be interacted\n    /// with as a custom account\n    /// - `Version1` means that the account follows the first version of the account abstraction protocol\n    enum AccountAbstractionVersion {\n        None,\n        Version1\n    }\n\n    /// @notice Defines the nonce ordering used by the account\n    /// - `Sequential` means that it is expected that the nonces are monotonic and increment by 1\n    /// at a time (the same as EOAs).\n    /// - `Arbitrary` means that the nonces for the accounts can be arbitrary. The operator\n    /// should serve the transactions from such an account on a first-come-first-serve basis.\n    /// @dev This ordering is more of a suggestion to the operator on how the AA expects its transactions\n    /// to be processed and is not considered as a system invariant.\n    enum AccountNonceOrdering {\n        Sequential,\n        Arbitrary\n    }\n\n    struct AccountInfo {\n        AccountAbstractionVersion supportedAAVersion;\n        AccountNonceOrdering nonceOrdering;\n    }\n\n    event ContractDeployed(\n        address indexed deployerAddress,\n        bytes32 indexed bytecodeHash,\n        address indexed contractAddress\n    );\n\n    event AccountNonceOrderingUpdated(address indexed accountAddress, AccountNonceOrdering nonceOrdering);\n\n    event AccountVersionUpdated(address indexed accountAddress, AccountAbstractionVersion aaVersion);\n\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) external view returns (address newAddress);\n\n    function getNewAddressCreate(address _sender, uint256 _senderNonce) external pure returns (address newAddress);\n\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress);\n\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) external payable returns (address newAddress);\n\n    /// @dev While the `_salt` parameter is not used anywhere here,\n    /// it is still needed for consistency between `create` and\n    /// `create2` functions (required by the compiler).\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress);\n\n    /// @dev While `_salt` is never used here, we leave it here as a parameter\n    /// for the consistency with the `create` function.\n    function createAccount(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) external payable returns (address newAddress);\n\n    /// @notice Returns the information about a certain AA.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info);\n\n    /// @notice Can be called by an account to update its account version\n    function updateAccountVersion(AccountAbstractionVersion _version) external;\n\n    /// @notice Can be called by an account to update its nonce ordering\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external;\n}\n\n\n\n//import \"./interfaces/IEthToken.sol\";\n\n\n\n\ninterface IEthToken {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function transferFromTo(address _from, address _to, uint256 _amount) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function mint(address _account, uint256 _amount) external;\n\n    function withdraw(address _l1Receiver) external payable;\n\n    event Mint(address indexed account, uint256 amount);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Withdrawal(address indexed _l2Sender, address indexed _l1Receiver, uint256 _amount);\n}\nuint160 constant SYSTEM_CONTRACTS_OFFSET = 0x8000; // 2^15\n\nIEthToken constant ETH_TOKEN_SYSTEM_CONTRACT = IEthToken(address(SYSTEM_CONTRACTS_OFFSET + 0x0a));\naddress payable constant BOOTLOADER_FORMAL_ADDRESS = payable(address(SYSTEM_CONTRACTS_OFFSET + 0x01));\n\n//import {ETH_TOKEN_SYSTEM_CONTRACT, BOOTLOADER_FORMAL_ADDRESS} from \"../Constants.sol\"; above\n\n\n//import \"./RLPEncoder.sol\";\nlibrary RLPEncoder {\n    function encodeAddress(address _val) internal pure returns (bytes memory encoded) {\n        // The size is equal to 20 bytes of the address itself + 1 for encoding bytes length in RLP.\n        encoded = new bytes(0x15);\n\n        bytes20 shiftedVal = bytes20(_val);\n        assembly {\n            // In the first byte we write the encoded length as 0x80 + 0x14 == 0x94.\n            mstore(add(encoded, 0x20), 0x9400000000000000000000000000000000000000000000000000000000000000)\n            // Write address data without stripping zeros.\n            mstore(add(encoded, 0x21), shiftedVal)\n        }\n    }\n\n    function encodeUint256(uint256 _val) internal pure returns (bytes memory encoded) {\n        unchecked {\n            if (_val < 128) {\n                encoded = new bytes(1);\n                // Handle zero as a non-value, since stripping zeroes results in an empty byte array\n                encoded[0] = (_val == 0) ? bytes1(uint8(128)) : bytes1(uint8(_val));\n            } else {\n                uint256 hbs = _highestByteSet(_val);\n\n                encoded = new bytes(hbs + 2);\n                encoded[0] = bytes1(uint8(hbs + 0x81));\n\n                uint256 lbs = 31 - hbs;\n                uint256 shiftedVal = _val << (lbs * 8);\n\n                assembly {\n                    mstore(add(encoded, 0x21), shiftedVal)\n                }\n            }\n        }\n    }\n\n    /// @notice Encodes the size of bytes in RLP format.\n    /// @param _len The length of the bytes to encode. It has a `uint64` type since as larger values are not supported.\n    /// NOTE: panics if the length is 1 since the length encoding is ambiguous in this case.\n    function encodeNonSingleBytesLen(uint64 _len) internal pure returns (bytes memory) {\n        assert(_len != 1);\n        return _encodeLength(_len, 0x80);\n    }\n\n    /// @notice Encodes the size of list items in RLP format.\n    /// @param _len The length of the bytes to encode. It has a `uint64` type since as larger values are not supported.\n    function encodeListLen(uint64 _len) internal pure returns (bytes memory) {\n        return _encodeLength(_len, 0xc0);\n    }\n\n    function _encodeLength(uint64 _len, uint256 _offset) private pure returns (bytes memory encoded) {\n        unchecked {\n            if (_len < 56) {\n                encoded = new bytes(1);\n                encoded[0] = bytes1(uint8(_len + _offset));\n            } else {\n                uint256 hbs = _highestByteSet(uint256(_len));\n\n                encoded = new bytes(hbs + 2);\n                encoded[0] = bytes1(uint8(_offset + hbs + 56));\n\n                uint256 lbs = 31 - hbs;\n                uint256 shiftedVal = uint256(_len) << (lbs * 8);\n\n                assembly {\n                    mstore(add(encoded, 0x21), shiftedVal)\n                }\n            }\n        }\n    }\n\n    /// @notice Computes the index of the highest byte set in number.\n    /// @notice Uses little endian ordering (The least significant byte has index `0`).\n    /// NOTE: returns `0` for `0`\n    function _highestByteSet(uint256 _number) private pure returns (uint256 hbs) {\n        unchecked {\n            if (_number > type(uint128).max) {\n                _number >>= 128;\n                hbs += 16;\n            }\n            if (_number > type(uint64).max) {\n                _number >>= 64;\n                hbs += 8;\n            }\n            if (_number > type(uint32).max) {\n                _number >>= 32;\n                hbs += 4;\n            }\n            if (_number > type(uint16).max) {\n                _number >>= 16;\n                hbs += 2;\n            }\n            if (_number > type(uint8).max) {\n                hbs += 1;\n            }\n        }\n    }\n}\n\n\n\n//import \"./EfficientCall.sol\";\n//inside is this\n//import \"./SystemContractHelper.sol\";\n\n//import {MAX_SYSTEM_CONTRACT_ADDRESS, MSG_VALUE_SYSTEM_CONTRACT} from \"../Constants.sol\";\nuint160 constant MAX_SYSTEM_CONTRACT_ADDRESS = 0xffff; // 2^16 - 1\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\n\n//import \"./SystemContractsCaller.sol\";\nuint256 constant MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT = 1;\n\n\n//import {MSG_VALUE_SYSTEM_CONTRACT, MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT} from \"../Constants.sol\";\n//import \"./Utils.sol\";\n//import \"./EfficientCall.sol\"; already imported\n\n/**\n * @author Matter Labs\n * @dev Common utilities used in zkSync system contracts\n */\nlibrary Utils {\n    /// @dev Bit mask of bytecode hash \"isConstructor\" marker\n    bytes32 constant IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK =\n        0x00ff000000000000000000000000000000000000000000000000000000000000;\n\n    /// @dev Bit mask to set the \"isConstructor\" marker in the bytecode hash\n    bytes32 constant SET_IS_CONSTRUCTOR_MARKER_BIT_MASK =\n        0x0001000000000000000000000000000000000000000000000000000000000000;\n\n    function safeCastToU128(uint256 _x) internal pure returns (uint128) {\n        require(_x <= type(uint128).max, \"Overflow\");\n\n        return uint128(_x);\n    }\n\n    function safeCastToU32(uint256 _x) internal pure returns (uint32) {\n        require(_x <= type(uint32).max, \"Overflow\");\n\n        return uint32(_x);\n    }\n\n    function safeCastToU24(uint256 _x) internal pure returns (uint24) {\n        require(_x <= type(uint24).max, \"Overflow\");\n\n        return uint24(_x);\n    }\n\n    /// @return codeLength The bytecode length in bytes\n    function bytecodeLenInBytes(bytes32 _bytecodeHash) internal pure returns (uint256 codeLength) {\n        codeLength = bytecodeLenInWords(_bytecodeHash) << 5; // _bytecodeHash * 32\n    }\n\n    /// @return codeLengthInWords The bytecode length in machine words\n    function bytecodeLenInWords(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        unchecked {\n            codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n        }\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that already constructed\n    function isContractConstructed(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x00;\n    }\n\n    /// @notice Denotes whether bytecode hash corresponds to a contract that is on constructor or has already been constructed\n    function isContractConstructing(bytes32 _bytecodeHash) internal pure returns (bool) {\n        return _bytecodeHash[1] == 0x01;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to TRUE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to TRUE\n    function constructingBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        // Clear the \"isConstructor\" marker and set it to 0x01.\n        return constructedBytecodeHash(_bytecodeHash) | SET_IS_CONSTRUCTOR_MARKER_BIT_MASK;\n    }\n\n    /// @notice Sets \"isConstructor\" flag to FALSE for the bytecode hash\n    /// @param _bytecodeHash The bytecode hash for which it is needed to set the constructing flag\n    /// @return The bytecode hash with \"isConstructor\" flag set to FALSE\n    function constructedBytecodeHash(bytes32 _bytecodeHash) internal pure returns (bytes32) {\n        return _bytecodeHash & ~IS_CONSTRUCTOR_BYTECODE_HASH_BIT_MASK;\n    }\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes calldata _bytecode) internal view returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"po\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2 ** 16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"pr\"); // bytecode length in words must be odd\n        hashedBytecode =\n            EfficientCall.sha(_bytecode) &\n            0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n}\n\n// Addresses used for the compiler to be replaced with the\n// zkSync-specific opcodes during the compilation.\n// IMPORTANT: these are just compile-time constants and are used\n// only if used in-place by Yul optimizer.\naddress constant TO_L1_CALL_ADDRESS = address((1 << 16) - 1);\naddress constant CODE_ADDRESS_CALL_ADDRESS = address((1 << 16) - 2);\naddress constant PRECOMPILE_CALL_ADDRESS = address((1 << 16) - 3);\naddress constant META_CALL_ADDRESS = address((1 << 16) - 4);\naddress constant MIMIC_CALL_CALL_ADDRESS = address((1 << 16) - 5);\naddress constant SYSTEM_MIMIC_CALL_CALL_ADDRESS = address((1 << 16) - 6);\naddress constant MIMIC_CALL_BY_REF_CALL_ADDRESS = address((1 << 16) - 7);\naddress constant SYSTEM_MIMIC_CALL_BY_REF_CALL_ADDRESS = address((1 << 16) - 8);\naddress constant RAW_FAR_CALL_CALL_ADDRESS = address((1 << 16) - 9);\naddress constant RAW_FAR_CALL_BY_REF_CALL_ADDRESS = address((1 << 16) - 10);\naddress constant SYSTEM_CALL_CALL_ADDRESS = address((1 << 16) - 11);\naddress constant SYSTEM_CALL_BY_REF_CALL_ADDRESS = address((1 << 16) - 12);\naddress constant SET_CONTEXT_VALUE_CALL_ADDRESS = address((1 << 16) - 13);\naddress constant SET_PUBDATA_PRICE_CALL_ADDRESS = address((1 << 16) - 14);\naddress constant INCREMENT_TX_COUNTER_CALL_ADDRESS = address((1 << 16) - 15);\naddress constant PTR_CALLDATA_CALL_ADDRESS = address((1 << 16) - 16);\naddress constant CALLFLAGS_CALL_ADDRESS = address((1 << 16) - 17);\naddress constant PTR_RETURNDATA_CALL_ADDRESS = address((1 << 16) - 18);\naddress constant EVENT_INITIALIZE_ADDRESS = address((1 << 16) - 19);\naddress constant EVENT_WRITE_ADDRESS = address((1 << 16) - 20);\naddress constant LOAD_CALLDATA_INTO_ACTIVE_PTR_CALL_ADDRESS = address((1 << 16) - 21);\naddress constant LOAD_LATEST_RETURNDATA_INTO_ACTIVE_PTR_CALL_ADDRESS = address((1 << 16) - 22);\naddress constant PTR_ADD_INTO_ACTIVE_CALL_ADDRESS = address((1 << 16) - 23);\naddress constant PTR_SHRINK_INTO_ACTIVE_CALL_ADDRESS = address((1 << 16) - 24);\naddress constant PTR_PACK_INTO_ACTIVE_CALL_ADDRESS = address((1 << 16) - 25);\naddress constant MULTIPLICATION_HIGH_ADDRESS = address((1 << 16) - 26);\naddress constant GET_EXTRA_ABI_DATA_ADDRESS = address((1 << 16) - 27);\n\n// All the offsets are in bits\nuint256 constant META_GAS_PER_PUBDATA_BYTE_OFFSET = 0 * 8;\nuint256 constant META_HEAP_SIZE_OFFSET = 8 * 8;\nuint256 constant META_AUX_HEAP_SIZE_OFFSET = 12 * 8;\nuint256 constant META_SHARD_ID_OFFSET = 28 * 8;\nuint256 constant META_CALLER_SHARD_ID_OFFSET = 29 * 8;\nuint256 constant META_CODE_SHARD_ID_OFFSET = 30 * 8;\n\n/// @notice The way to forward the calldata:\n/// - Use the current heap (i.e. the same as on EVM).\n/// - Use the auxiliary heap.\n/// - Forward via a pointer\n/// @dev Note, that currently, users do not have access to the auxiliary\n/// heap and so the only type of forwarding that will be used by the users\n/// are UseHeap and ForwardFatPointer for forwarding a slice of the current calldata\n/// to the next call.\nenum CalldataForwardingMode {\n    UseHeap,\n    ForwardFatPointer,\n    UseAuxHeap\n}\n\n/**\n * @author Matter Labs\n * @notice A library that allows calling contracts with the `isSystem` flag.\n * @dev It is needed to call ContractDeployer and NonceHolder.\n */\nlibrary SystemContractsCaller {\n    /// @notice Makes a call with the `isSystem` flag.\n    /// @param gasLimit The gas limit for the call.\n    /// @param to The address to call.\n    /// @param value The value to pass with the transaction.\n    /// @param data The calldata.\n    /// @return success Whether the transaction has been successful.\n    /// @dev Note, that the `isSystem` flag can only be set when calling system contracts.\n    function systemCall(uint32 gasLimit, address to, uint256 value, bytes memory data) internal returns (bool success) {\n        address callAddr = SYSTEM_CALL_CALL_ADDRESS;\n\n        uint32 dataStart;\n        assembly {\n            dataStart := add(data, 0x20)\n        }\n        uint32 dataLength = uint32(Utils.safeCastToU32(data.length));\n\n        uint256 farCallAbi = SystemContractsCaller.getFarCallABI(\n            0,\n            0,\n            dataStart,\n            dataLength,\n            gasLimit,\n            // Only rollup is supported for now\n            0,\n            CalldataForwardingMode.UseHeap,\n            false,\n            true\n        );\n\n        if (value == 0) {\n            // Doing the system call directly\n            assembly {\n                success := call(to, callAddr, 0, 0, farCallAbi, 0, 0)\n            }\n        } else {\n            address msgValueSimulator = MSG_VALUE_SYSTEM_CONTRACT;\n            // We need to supply the mask to the MsgValueSimulator to denote\n            // that the call should be a system one.\n            uint256 forwardMask = MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT;\n\n            assembly {\n                success := call(msgValueSimulator, callAddr, value, to, farCallAbi, forwardMask, 0)\n            }\n        }\n    }\n\n    /// @notice Makes a call with the `isSystem` flag.\n    /// @param gasLimit The gas limit for the call.\n    /// @param to The address to call.\n    /// @param value The value to pass with the transaction.\n    /// @param data The calldata.\n    /// @return success Whether the transaction has been successful.\n    /// @return returnData The returndata of the transaction (revert reason in case the transaction has failed).\n    /// @dev Note, that the `isSystem` flag can only be set when calling system contracts.\n    function systemCallWithReturndata(\n        uint32 gasLimit,\n        address to,\n        uint128 value,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        success = systemCall(gasLimit, to, value, data);\n\n        uint256 size;\n        assembly {\n            size := returndatasize()\n        }\n\n        returnData = new bytes(size);\n        assembly {\n            returndatacopy(add(returnData, 0x20), 0, size)\n        }\n    }\n\n    /// @notice Makes a call with the `isSystem` flag.\n    /// @param gasLimit The gas limit for the call.\n    /// @param to The address to call.\n    /// @param value The value to pass with the transaction.\n    /// @param data The calldata.\n    /// @return returnData The returndata of the transaction. In case the transaction reverts, the error\n    /// bubbles up to the parent frame.\n    /// @dev Note, that the `isSystem` flag can only be set when calling system contracts.\n    function systemCallWithPropagatedRevert(\n        uint32 gasLimit,\n        address to,\n        uint128 value,\n        bytes memory data\n    ) internal returns (bytes memory returnData) {\n        bool success;\n        (success, returnData) = systemCallWithReturndata(gasLimit, to, value, data);\n\n        if (!success) {\n            assembly {\n                let size := mload(returnData)\n                revert(add(returnData, 0x20), size)\n            }\n        }\n    }\n\n    /// @notice Calculates the packed representation of the FarCallABI.\n    /// @param dataOffset Calldata offset in memory. Provide 0 unless using custom pointer.\n    /// @param memoryPage Memory page to use. Provide 0 unless using custom pointer.\n    /// @param dataStart The start of the calldata slice. Provide the offset in memory\n    /// if not using custom pointer.\n    /// @param dataLength The calldata length. Provide the length of the calldata in bytes\n    /// unless using custom pointer.\n    /// @param gasPassed The gas to pass with the call.\n    /// @param shardId Of the account to call. Currently only 0 is supported.\n    /// @param forwardingMode The forwarding mode to use:\n    /// - provide CalldataForwardingMode.UseHeap when using your current memory\n    /// - provide CalldataForwardingMode.ForwardFatPointer when using custom pointer.\n    /// @param isConstructorCall Whether the call will be a call to the constructor\n    /// (ignored when the caller is not a system contract).\n    /// @param isSystemCall Whether the call will have the `isSystem` flag.\n    /// @return farCallAbi The far call ABI.\n    /// @dev The `FarCallABI` has the following structure:\n    /// pub struct FarCallABI {\n    ///     pub memory_quasi_fat_pointer: FatPointer,\n    ///     pub gas_passed: u32,\n    ///     pub shard_id: u8,\n    ///     pub forwarding_mode: FarCallForwardPageType,\n    ///     pub constructor_call: bool,\n    ///     pub to_system: bool,\n    /// }\n    ///\n    /// The FatPointer struct:\n    ///\n    /// pub struct FatPointer {\n    ///     pub offset: u32, // offset relative to `start`\n    ///     pub memory_page: u32, // memory page where slice is located\n    ///     pub start: u32, // absolute start of the slice\n    ///     pub length: u32, // length of the slice\n    /// }\n    ///\n    /// @dev Note, that the actual layout is the following:\n    ///\n    /// [0..32) bits -- the calldata offset\n    /// [32..64) bits -- the memory page to use. Can be left blank in most of the cases.\n    /// [64..96) bits -- the absolute start of the slice\n    /// [96..128) bits -- the length of the slice.\n    /// [128..192) bits -- empty bits.\n    /// [192..224) bits -- gasPassed.\n    /// [224..232) bits -- forwarding_mode\n    /// [232..240) bits -- shard id.\n    /// [240..248) bits -- constructor call flag\n    /// [248..256] bits -- system call flag\n    function getFarCallABI(\n        uint32 dataOffset,\n        uint32 memoryPage,\n        uint32 dataStart,\n        uint32 dataLength,\n        uint32 gasPassed,\n        uint8 shardId,\n        CalldataForwardingMode forwardingMode,\n        bool isConstructorCall,\n        bool isSystemCall\n    ) internal pure returns (uint256 farCallAbi) {\n        // Fill in the call parameter fields\n        farCallAbi = getFarCallABIWithEmptyFatPointer(\n            gasPassed,\n            shardId,\n            forwardingMode,\n            isConstructorCall,\n            isSystemCall\n        );\n        // Fill in the fat pointer fields\n        farCallAbi |= dataOffset;\n        farCallAbi |= (uint256(memoryPage) << 32);\n        farCallAbi |= (uint256(dataStart) << 64);\n        farCallAbi |= (uint256(dataLength) << 96);\n    }\n\n    /// @notice Calculates the packed representation of the FarCallABI with zero fat pointer fields.\n    /// @param gasPassed The gas to pass with the call.\n    /// @param shardId Of the account to call. Currently only 0 is supported.\n    /// @param forwardingMode The forwarding mode to use:\n    /// - provide CalldataForwardingMode.UseHeap when using your current memory\n    /// - provide CalldataForwardingMode.ForwardFatPointer when using custom pointer.\n    /// @param isConstructorCall Whether the call will be a call to the constructor\n    /// (ignored when the caller is not a system contract).\n    /// @param isSystemCall Whether the call will have the `isSystem` flag.\n    /// @return farCallAbiWithEmptyFatPtr The far call ABI with zero fat pointer fields.\n    function getFarCallABIWithEmptyFatPointer(\n        uint32 gasPassed,\n        uint8 shardId,\n        CalldataForwardingMode forwardingMode,\n        bool isConstructorCall,\n        bool isSystemCall\n    ) internal pure returns (uint256 farCallAbiWithEmptyFatPtr) {\n        farCallAbiWithEmptyFatPtr |= (uint256(gasPassed) << 192);\n        farCallAbiWithEmptyFatPtr |= (uint256(forwardingMode) << 224);\n        farCallAbiWithEmptyFatPtr |= (uint256(shardId) << 232);\n        if (isConstructorCall) {\n            farCallAbiWithEmptyFatPtr |= (1 << 240);\n        }\n        if (isSystemCall) {\n            farCallAbiWithEmptyFatPtr |= (1 << 248);\n        }\n    }\n}\n\n//import \"./Utils.sol\"; already imprted\n\nuint256 constant UINT32_MASK = 0xffffffff;\nuint256 constant UINT128_MASK = 0xffffffffffffffffffffffffffffffff;\n/// @dev The mask that is used to convert any uint256 to a proper address.\n/// It needs to be padded with `00` to be treated as uint256 by Solidity\nuint256 constant ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n\nstruct ZkSyncMeta {\n    uint32 gasPerPubdataByte;\n    uint32 heapSize;\n    uint32 auxHeapSize;\n    uint8 shardId;\n    uint8 callerShardId;\n    uint8 codeShardId;\n}\n\nenum Global {\n    CalldataPtr,\n    CallFlags,\n    ExtraABIData1,\n    ExtraABIData2,\n    ReturndataPtr\n}\n\n/**\n * @author Matter Labs\n * @notice Library used for accessing zkEVM-specific opcodes, needed for the development\n * of system contracts.\n * @dev While this library will be eventually available to public, some of the provided\n * methods won't work for non-system contracts. We will not recommend this library\n * for external use.\n */\nlibrary SystemContractHelper {\n    /// @notice Send an L2Log to L1.\n    /// @param _isService The `isService` flag.\n    /// @param _key The `key` part of the L2Log.\n    /// @param _value The `value` part of the L2Log.\n    /// @dev The meaning of all these parameters is context-dependent, but they\n    /// have no intrinsic meaning per se.\n    function toL1(bool _isService, bytes32 _key, bytes32 _value) internal {\n        address callAddr = TO_L1_CALL_ADDRESS;\n        assembly {\n            // Ensuring that the type is bool\n            _isService := and(_isService, 1)\n            // This `success` is always 0, but the method always succeeds\n            // (except for the cases when there is not enough gas)\n            let success := call(_isService, callAddr, _key, _value, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Get address of the currently executed code.\n    /// @dev This allows differentiating between `call` and `delegatecall`.\n    /// During the former `this` and `codeAddress` are the same, while\n    /// during the latter they are not.\n    function getCodeAddress() internal view returns (address addr) {\n        address callAddr = CODE_ADDRESS_CALL_ADDRESS;\n        assembly {\n            addr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Provide a compiler hint, by placing calldata fat pointer into virtual `ACTIVE_PTR`,\n    /// that can be manipulated by `ptr.add`/`ptr.sub`/`ptr.pack`/`ptr.shrink` later.\n    /// @dev This allows making a call by forwarding calldata pointer to the child call.\n    /// It is a much more efficient way to forward calldata, than standard EVM bytes copying.\n    function loadCalldataIntoActivePtr() internal view {\n        address callAddr = LOAD_CALLDATA_INTO_ACTIVE_PTR_CALL_ADDRESS;\n        assembly {\n            pop(staticcall(0, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.pack` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Do the concatenation between lowest part of `ACTIVE_PTR` and highest part of `_farCallAbi`\n    /// forming packed fat pointer for a far call or ret ABI when necessary.\n    /// Note: Panics if the lowest 128 bits of `_farCallAbi` are not zeroes.\n    function ptrPackIntoActivePtr(uint256 _farCallAbi) internal view {\n        address callAddr = PTR_PACK_INTO_ACTIVE_CALL_ADDRESS;\n        assembly {\n            pop(staticcall(_farCallAbi, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.add` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Transforms `ACTIVE_PTR.offset` into `ACTIVE_PTR.offset + u32(_value)`. If overflow happens then it panics.\n    function ptrAddIntoActive(uint32 _value) internal view {\n        address callAddr = PTR_ADD_INTO_ACTIVE_CALL_ADDRESS;\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _value := and(_value, cleanupMask)\n            pop(staticcall(_value, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.shrink` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Transforms `ACTIVE_PTR.length` into `ACTIVE_PTR.length - u32(_shrink)`. If underflow happens then it panics.\n    function ptrShrinkIntoActive(uint32 _shrink) internal view {\n        address callAddr = PTR_SHRINK_INTO_ACTIVE_CALL_ADDRESS;\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _shrink := and(_shrink, cleanupMask)\n            pop(staticcall(_shrink, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice packs precompile parameters into one word\n    /// @param _inputMemoryOffset The memory offset in 32-byte words for the input data for calling the precompile.\n    /// @param _inputMemoryLength The length of the input data in words.\n    /// @param _outputMemoryOffset The memory offset in 32-byte words for the output data.\n    /// @param _outputMemoryLength The length of the output data in words.\n    /// @param _perPrecompileInterpreted The constant, the meaning of which is defined separately for\n    /// each precompile. For information, please read the documentation of the precompilecall log in\n    /// the VM.\n    function packPrecompileParams(\n        uint32 _inputMemoryOffset,\n        uint32 _inputMemoryLength,\n        uint32 _outputMemoryOffset,\n        uint32 _outputMemoryLength,\n        uint64 _perPrecompileInterpreted\n    ) internal pure returns (uint256 rawParams) {\n        rawParams = _inputMemoryOffset;\n        rawParams |= uint256(_inputMemoryLength) << 32;\n        rawParams |= uint256(_outputMemoryOffset) << 64;\n        rawParams |= uint256(_outputMemoryLength) << 96;\n        rawParams |= uint256(_perPrecompileInterpreted) << 192;\n    }\n\n    /// @notice Call precompile with given parameters.\n    /// @param _rawParams The packed precompile params. They can be retrieved by\n    /// the `packPrecompileParams` method.\n    /// @param _gasToBurn The number of gas to burn during this call.\n    /// @return success Whether the call was successful.\n    /// @dev The list of currently available precompiles sha256, keccak256, ecrecover.\n    /// NOTE: The precompile type depends on `this` which calls precompile, which means that only\n    /// system contracts corresponding to the list of precompiles above can do `precompileCall`.\n    /// @dev If used not in the `sha256`, `keccak256` or `ecrecover` contracts, it will just burn the gas provided.\n    function precompileCall(uint256 _rawParams, uint32 _gasToBurn) internal view returns (bool success) {\n        address callAddr = PRECOMPILE_CALL_ADDRESS;\n\n        // After `precompileCall` gas will be burned down to 0 if there are not enough of them,\n        // thats why it should be checked before the call.\n        require(gasleft() >= _gasToBurn);\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _gasToBurn := and(_gasToBurn, cleanupMask)\n            success := staticcall(_rawParams, callAddr, _gasToBurn, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Set `msg.value` to next far call.\n    /// @param _value The msg.value that will be used for the *next* call.\n    /// @dev If called not in kernel mode, it will result in a revert (enforced by the VM)\n    function setValueForNextFarCall(uint128 _value) internal returns (bool success) {\n        uint256 cleanupMask = UINT128_MASK;\n        address callAddr = SET_CONTEXT_VALUE_CALL_ADDRESS;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _value := and(_value, cleanupMask)\n            success := call(0, callAddr, _value, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Initialize a new event.\n    /// @param initializer The event initializing value.\n    /// @param value1 The first topic or data chunk.\n    function eventInitialize(uint256 initializer, uint256 value1) internal {\n        address callAddr = EVENT_INITIALIZE_ADDRESS;\n        assembly {\n            pop(call(initializer, callAddr, value1, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Continue writing the previously initialized event.\n    /// @param value1 The first topic or data chunk.\n    /// @param value2 The second topic or data chunk.\n    function eventWrite(uint256 value1, uint256 value2) internal {\n        address callAddr = EVENT_WRITE_ADDRESS;\n        assembly {\n            pop(call(value1, callAddr, value2, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Get the packed representation of the `ZkSyncMeta` from the current context.\n    /// @return meta The packed representation of the ZkSyncMeta.\n    /// @dev The fields in ZkSyncMeta are NOT tightly packed, i.e. there is a special rule on how\n    /// they are packed. For more information, please read the documentation on ZkSyncMeta.\n    function getZkSyncMetaBytes() internal view returns (uint256 meta) {\n        address callAddr = META_CALL_ADDRESS;\n        assembly {\n            meta := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the bits [offset..offset+size-1] of the meta.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @param offset The offset of the bits.\n    /// @param size The size of the extracted number in bits.\n    /// @return result The extracted number.\n    function extractNumberFromMeta(uint256 meta, uint256 offset, uint256 size) internal pure returns (uint256 result) {\n        // Firstly, we delete all the bits after the field\n        uint256 shifted = (meta << (256 - size - offset));\n        // Then we shift everything back\n        result = (shifted >> (256 - size));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of gas\n    /// that a single byte sent to L1 as pubdata costs.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return gasPerPubdataByte The current price in gas per pubdata byte.\n    function getGasPerPubdataByteFromMeta(uint256 meta) internal pure returns (uint32 gasPerPubdataByte) {\n        gasPerPubdataByte = uint32(extractNumberFromMeta(meta, META_GAS_PER_PUBDATA_BYTE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of the current size\n    /// of the heap in bytes.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return heapSize The size of the memory in bytes byte.\n    /// @dev The following expression: getHeapSizeFromMeta(getZkSyncMetaBytes()) is\n    /// equivalent to the MSIZE in Solidity.\n    function getHeapSizeFromMeta(uint256 meta) internal pure returns (uint32 heapSize) {\n        heapSize = uint32(extractNumberFromMeta(meta, META_HEAP_SIZE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of the current size\n    /// of the auxilary heap in bytes.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return auxHeapSize The size of the auxilary memory in bytes byte.\n    /// @dev You can read more on auxilary memory in the VM1.2 documentation.\n    function getAuxHeapSizeFromMeta(uint256 meta) internal pure returns (uint32 auxHeapSize) {\n        auxHeapSize = uint32(extractNumberFromMeta(meta, META_AUX_HEAP_SIZE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of `this`.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return shardId The shardId of `this`.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getShardIdFromMeta(uint256 meta) internal pure returns (uint8 shardId) {\n        shardId = uint8(extractNumberFromMeta(meta, META_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of\n    /// the msg.sender.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return callerShardId The shardId of the msg.sender.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getCallerShardIdFromMeta(uint256 meta) internal pure returns (uint8 callerShardId) {\n        callerShardId = uint8(extractNumberFromMeta(meta, META_CALLER_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of\n    /// the currently executed code.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return codeShardId The shardId of the currently executed code.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getCodeShardIdFromMeta(uint256 meta) internal pure returns (uint8 codeShardId) {\n        codeShardId = uint8(extractNumberFromMeta(meta, META_CODE_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Retrieves the ZkSyncMeta structure.\n    /// @return meta The ZkSyncMeta execution context parameters.\n    function getZkSyncMeta() internal view returns (ZkSyncMeta memory meta) {\n        uint256 metaPacked = getZkSyncMetaBytes();\n        meta.gasPerPubdataByte = getGasPerPubdataByteFromMeta(metaPacked);\n        meta.shardId = getShardIdFromMeta(metaPacked);\n        meta.callerShardId = getCallerShardIdFromMeta(metaPacked);\n        meta.codeShardId = getCodeShardIdFromMeta(metaPacked);\n    }\n\n    /// @notice Returns the call flags for the current call.\n    /// @return callFlags The bitmask of the callflags.\n    /// @dev Call flags is the value of the first register\n    /// at the start of the call.\n    /// @dev The zero bit of the callFlags indicates whether the call is\n    /// a constructor call. The first bit of the callFlags indicates whether\n    /// the call is a system one.\n    function getCallFlags() internal view returns (uint256 callFlags) {\n        address callAddr = CALLFLAGS_CALL_ADDRESS;\n        assembly {\n            callFlags := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the current calldata pointer.\n    /// @return ptr The current calldata pointer.\n    /// @dev NOTE: This file is just an integer and it can not be used\n    /// to forward the calldata to the next calls in any way.\n    function getCalldataPtr() internal view returns (uint256 ptr) {\n        address callAddr = PTR_CALLDATA_CALL_ADDRESS;\n        assembly {\n            ptr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the N-th extraAbiParam for the current call.\n    /// @return extraAbiData The value of the N-th extraAbiParam for this call.\n    /// @dev It is equal to the value of the (N+2)-th register\n    /// at the start of the call.\n    function getExtraAbiData(uint256 index) internal view returns (uint256 extraAbiData) {\n        require(index < 10, \"There are only 10 accessible registers\");\n\n        address callAddr = GET_EXTRA_ABI_DATA_ADDRESS;\n        assembly {\n            extraAbiData := staticcall(index, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Retuns whether the current call is a system call.\n    /// @return `true` or `false` based on whether the current call is a system call.\n    function isSystemCall() internal view returns (bool) {\n        uint256 callFlags = getCallFlags();\n        // When the system call is passed, the 2-bit it set to 1\n        return (callFlags & 2) != 0;\n    }\n\n    /// @notice Returns whether the address is a system contract.\n    /// @param _address The address to test\n    /// @return `true` or `false` based on whether the `_address` is a system contract.\n    function isSystemContract(address _address) internal pure returns (bool) {\n        return uint160(_address) <= uint160(MAX_SYSTEM_CONTRACT_ADDRESS);\n    }\n}\n\n/// @dev Solidity does not allow exporting modifiers via libraries, so\n/// the only way to do reuse modifiers is to have a base contract\nabstract contract ISystemContract {\n    /// @notice Modifier that makes sure that the method\n    /// can only be called via a system call.\n    modifier onlySystemCall() {\n        require(\n            SystemContractHelper.isSystemCall() || SystemContractHelper.isSystemContract(msg.sender),\n            \"This method require system call flag\"\n        );\n        _;\n    }\n}\n\n//import \"./Utils.sol\"; already imported\n//import {SHA256_SYSTEM_CONTRACT, KECCAK256_SYSTEM_CONTRACT} from \"../Constants.sol\";\naddress constant SHA256_SYSTEM_CONTRACT = address(0x02);\naddress constant KECCAK256_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x10);\n\n/**\n * @author Matter Labs\n * @notice This library is used to perform ultra-efficient calls using zkEVM-specific features.\n * @dev EVM calls always accept a memory slice as input and return a memory slice as output.\n * Therefore, even if the user has a ready-made calldata slice, they still need to copy it to memory\n * before calling. This is especially inefficient for large inputs (proxies, multi-calls, etc.).\n * In turn, zkEVM operates over a fat pointer, which is a set of (memory page, offset, start, length) in the memory/calldata/returndata.\n * This allows forwarding the calldata slice as is, without copying it to memory.\n * @dev Fat pointer is not just an integer, it is an extended data type supported on the VM level.\n * zkEVM creates the wellformed fat pointers for all the calldata/returndata regions, later\n * the contract may manipulate the already created fat pointers to forward a slice of the data, but not\n * to create new fat pointers!\n * @dev The allowed operation on fat pointers are:\n * 1. `ptr.add` - Transforms `ptr.offset` into `ptr.offset + u32(_value)`. If overflow happens then it panics.\n * 2. `ptr.sub` - Transforms `ptr.offset` into `ptr.offset - u32(_value)`. If underflow happens then it panics.\n * 3. `ptr.pack` - Do the concatenation between the lowest 128 bits of the pointer itself and the highest 128 bits of `_value`. It is typically used to prepare the ABI for external calls.\n * 4. `ptr.shrink` - Transforms `ptr.length` into `ptr.length - u32(_shrink)`. If underflow happens then it panics.\n * @dev The call opcodes accept the fat pointer and change it to its canonical form before passing it to the child call\n * 1. `ptr.start` is transformed into `ptr.offset + ptr.start`\n * 2. `ptr.length` is transformed into `ptr.length - ptr.offset`\n * 3. `ptr.offset` is transformed into `0`\n */\nlibrary EfficientCall {\n    /// @notice Call the `keccak256` without copying calldata to memory.\n    /// @param _data The preimage data.\n    /// @return The `keccak256` hash.\n    function keccak(bytes calldata _data) internal view returns (bytes32) {\n        bytes memory returnData = staticCall(gasleft(), KECCAK256_SYSTEM_CONTRACT, _data);\n        require(returnData.length == 32, \"keccak256 returned invalid data\");\n        return bytes32(returnData);\n    }\n\n    /// @notice Call the `sha256` precompile without copying calldata to memory.\n    /// @param _data The preimage data.\n    /// @return The `sha256` hash.\n    function sha(bytes calldata _data) internal view returns (bytes32) {\n        bytes memory returnData = staticCall(gasleft(), SHA256_SYSTEM_CONTRACT, _data);\n        require(returnData.length == 32, \"sha returned invalid data\");\n        return bytes32(returnData);\n    }\n\n    /// @notice Perform a `call` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _value The `msg.value` to send.\n    /// @param _data The calldata to use for the call.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return returnData The copied to memory return data.\n    function call(\n        uint256 _gas,\n        address _address,\n        uint256 _value,\n        bytes calldata _data,\n        bool _isSystem\n    ) internal returns (bytes memory returnData) {\n        bool success = rawCall(_gas, _address, _value, _data, _isSystem);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `staticCall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return returnData The copied to memory return data.\n    function staticCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data\n    ) internal view returns (bytes memory returnData) {\n        bool success = rawStaticCall(_gas, _address, _data);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `delegateCall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return returnData The copied to memory return data.\n    function delegateCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data\n    ) internal returns (bytes memory returnData) {\n        bool success = rawDelegateCall(_gas, _address, _data);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `mimicCall` (a call with custom msg.sender) without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @param _whoToMimic The `msg.sender` for the next call.\n    /// @param _isConstructor Whether the call should contain the `isConstructor` flag.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return returnData The copied to memory return data.\n    function mimicCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data,\n        address _whoToMimic,\n        bool _isConstructor,\n        bool _isSystem\n    ) internal returns (bytes memory returnData) {\n        bool success = rawMimicCall(_gas, _address, _data, _whoToMimic, _isConstructor, _isSystem);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `call` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _value The `msg.value` to send.\n    /// @param _data The calldata to use for the call.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return success whether the call was successful.\n    function rawCall(\n        uint256 _gas,\n        address _address,\n        uint256 _value,\n        bytes calldata _data,\n        bool _isSystem\n    ) internal returns (bool success) {\n        if (_value == 0) {\n            _loadFarCallABIIntoActivePtr(_gas, _data, false, _isSystem);\n\n            address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;\n            assembly {\n                success := call(_address, callAddr, 0, 0, 0xFFFF, 0, 0)\n            }\n        } else {\n            _loadFarCallABIIntoActivePtr(_gas, _data, false, true);\n\n            // If there is provided `msg.value` call the `MsgValueSimulator` to forward ether.\n            address msgValueSimulator = MSG_VALUE_SYSTEM_CONTRACT;\n            address callAddr = SYSTEM_CALL_BY_REF_CALL_ADDRESS;\n            // We need to supply the mask to the MsgValueSimulator to denote\n            // that the call should be a system one.\n            uint256 forwardMask = _isSystem ? MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT : 0;\n\n            assembly {\n                success := call(msgValueSimulator, callAddr, _value, _address, 0xFFFF, forwardMask, 0)\n            }\n        }\n    }\n\n    /// @notice Perform a `staticCall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return success whether the call was successful.\n    function rawStaticCall(uint256 _gas, address _address, bytes calldata _data) internal view returns (bool success) {\n        _loadFarCallABIIntoActivePtr(_gas, _data, false, false);\n\n        address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;\n        assembly {\n            success := staticcall(_address, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Perform a `delegatecall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return success whether the call was successful.\n    function rawDelegateCall(uint256 _gas, address _address, bytes calldata _data) internal returns (bool success) {\n        _loadFarCallABIIntoActivePtr(_gas, _data, false, false);\n\n        address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;\n        assembly {\n            success := delegatecall(_address, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Perform a `mimicCall` (call with custom msg.sender) without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @param _whoToMimic The `msg.sender` for the next call.\n    /// @param _isConstructor Whether the call should contain the `isConstructor` flag.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return success whether the call was successful.\n    /// @dev If called not in kernel mode, it will result in a revert (enforced by the VM)\n    function rawMimicCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data,\n        address _whoToMimic,\n        bool _isConstructor,\n        bool _isSystem\n    ) internal returns (bool success) {\n        _loadFarCallABIIntoActivePtr(_gas, _data, _isConstructor, _isSystem);\n\n        address callAddr = MIMIC_CALL_BY_REF_CALL_ADDRESS;\n        uint256 cleanupMask = ADDRESS_MASK;\n        assembly {\n            // Clearing values before usage in assembly, since Solidity\n            // doesn't do it by default\n            _whoToMimic := and(_whoToMimic, cleanupMask)\n\n            success := call(_address, callAddr, 0, 0, _whoToMimic, 0, 0)\n        }\n    }\n\n    /// @dev Verify that a low-level call was successful, and revert if it wasn't, by bubbling the revert reason.\n    /// @param _success Whether the call was successful.\n    /// @return returnData The copied to memory return data.\n    function _verifyCallResult(bool _success) private pure returns (bytes memory returnData) {\n        if (_success) {\n            uint256 size;\n            assembly {\n                size := returndatasize()\n            }\n\n            returnData = new bytes(size);\n            assembly {\n                returndatacopy(add(returnData, 0x20), 0, size)\n            }\n        } else {\n            propagateRevert();\n        }\n    }\n\n    /// @dev Propagate the revert reason from the current call to the caller.\n    function propagateRevert() internal pure {\n        assembly {\n            let size := returndatasize()\n            returndatacopy(0, 0, size)\n            revert(0, size)\n        }\n    }\n\n    /// @dev Load the far call ABI into active ptr, that will be used for the next call by reference.\n    /// @param _gas The gas to be passed to the call.\n    /// @param _data The calldata to be passed to the call.\n    /// @param _isConstructor Whether the call is a constructor call.\n    /// @param _isSystem Whether the call is a system call.\n    function _loadFarCallABIIntoActivePtr(\n        uint256 _gas,\n        bytes calldata _data,\n        bool _isConstructor,\n        bool _isSystem\n    ) private view {\n        SystemContractHelper.loadCalldataIntoActivePtr();\n\n        // Currently, zkEVM considers the pointer valid if(ptr.offset < ptr.length || (ptr.length == 0 && ptr.offset == 0)), otherwise panics.\n        // So, if the data is empty we need to make the `ptr.length = ptr.offset = 0`, otherwise follow standard logic.\n        if (_data.length == 0) {\n            // Safe to cast, offset is never bigger than `type(uint32).max`\n            SystemContractHelper.ptrShrinkIntoActive(uint32(msg.data.length));\n        } else {\n            uint256 dataOffset;\n            assembly {\n                dataOffset := _data.offset\n            }\n\n            // Safe to cast, offset is never bigger than `type(uint32).max`\n            SystemContractHelper.ptrAddIntoActive(uint32(dataOffset));\n            // Safe to cast, `data.length` is never bigger than `type(uint32).max`\n            uint32 shrinkTo = uint32(msg.data.length - (_data.length + dataOffset));\n            SystemContractHelper.ptrShrinkIntoActive(shrinkTo);\n        }\n\n        uint32 gas = Utils.safeCastToU32(_gas);\n        uint256 farCallAbi = SystemContractsCaller.getFarCallABIWithEmptyFatPointer(\n            gas,\n            // Only rollup is supported for now\n            0,\n            CalldataForwardingMode.ForwardFatPointer,\n            _isConstructor,\n            _isSystem\n        );\n        SystemContractHelper.ptrPackIntoActivePtr(farCallAbi);\n    }\n}\n\n\n\n\n/// @dev The type id of zkSync's EIP-712-signed transaction.\nuint8 constant EIP_712_TX_TYPE = 0x71;\n\n/// @dev The type id of legacy transactions.\nuint8 constant LEGACY_TX_TYPE = 0x0;\n/// @dev The type id of legacy transactions.\nuint8 constant EIP_2930_TX_TYPE = 0x01;\n/// @dev The type id of EIP1559 transactions.\nuint8 constant EIP_1559_TX_TYPE = 0x02;\n\n/// @notice Structure used to represent zkSync transaction.\nstruct Transaction {\n    // The type of the transaction.\n    uint256 txType;\n    // The caller.\n    uint256 from;\n    // The callee.\n    uint256 to;\n    // The gasLimit to pass with the transaction.\n    // It has the same meaning as Ethereum's gasLimit.\n    uint256 gasLimit;\n    // The maximum amount of gas the user is willing to pay for a byte of pubdata.\n    uint256 gasPerPubdataByteLimit;\n    // The maximum fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxFeePerGas.\n    uint256 maxFeePerGas;\n    // The maximum priority fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxPriorityFeePerGas.\n    uint256 maxPriorityFeePerGas;\n    // The transaction's paymaster. If there is no paymaster, it is equal to 0.\n    uint256 paymaster;\n    // The nonce of the transaction.\n    uint256 nonce;\n    // The value to pass with the transaction.\n    uint256 value;\n    // In the future, we might want to add some\n    // new fields to the struct. The `txData` struct\n    // is to be passed to account and any changes to its structure\n    // would mean a breaking change to these accounts. In order to prevent this,\n    // we should keep some fields as \"reserved\".\n    // It is also recommended that their length is fixed, since\n    // it would allow easier proof integration (in case we will need\n    // some special circuit for preprocessing transactions).\n    uint256[4] reserved;\n    // The transaction's calldata.\n    bytes data;\n    // The signature of the transaction.\n    bytes signature;\n    // The properly formatted hashes of bytecodes that must be published on L1\n    // with the inclusion of this transaction. Note, that a bytecode has been published\n    // before, the user won't pay fees for its republishing.\n    bytes32[] factoryDeps;\n    // The input to the paymaster.\n    bytes paymasterInput;\n    // Reserved dynamic type for the future use-case. Using it should be avoided,\n    // But it is still here, just in case we want to enable some additional functionality.\n    bytes reservedDynamic;\n}\n\n/**\n * @author Matter Labs\n * @notice Library is used to help custom accounts to work with common methods for the Transaction type.\n */\nlibrary TransactionHelper {\n    using SafeERC20 for IERC20;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 constant EIP712_DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\");\n\n    bytes32 constant EIP712_TRANSACTION_TYPE_HASH =\n        keccak256(\n            \"Transaction(uint256 txType,uint256 from,uint256 to,uint256 gasLimit,uint256 gasPerPubdataByteLimit,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 paymaster,uint256 nonce,uint256 value,bytes data,bytes32[] factoryDeps,bytes paymasterInput)\"\n        );\n\n    /// @notice Whether the token is Ethereum.\n    /// @param _addr The address of the token\n    /// @return `true` or `false` based on whether the token is Ether.\n    /// @dev This method assumes that address is Ether either if the address is 0 (for convenience)\n    /// or if the address is the address of the L2EthToken system contract.\n    function isEthToken(uint256 _addr) internal pure returns (bool) {\n        return _addr == uint256(uint160(address(ETH_TOKEN_SYSTEM_CONTRACT))) || _addr == 0;\n    }\n\n    /// @notice Calculate the suggested signed hash of the transaction,\n    /// i.e. the hash that is signed by EOAs and is recommended to be signed by other accounts.\n    function encodeHash(Transaction calldata _transaction) internal view returns (bytes32 resultHash) {\n        if (_transaction.txType == LEGACY_TX_TYPE) {\n            resultHash = _encodeHashLegacyTransaction(_transaction);\n        } else if (_transaction.txType == EIP_712_TX_TYPE) {\n            resultHash = _encodeHashEIP712Transaction(_transaction);\n        } else if (_transaction.txType == EIP_1559_TX_TYPE) {\n            resultHash = _encodeHashEIP1559Transaction(_transaction);\n        } else if (_transaction.txType == EIP_2930_TX_TYPE) {\n            resultHash = _encodeHashEIP2930Transaction(_transaction);\n        } else {\n            // Currently no other transaction types are supported.\n            // Any new transaction types will be processed in a similar manner.\n            revert(\"Encoding unsupported tx\");\n        }\n    }\n\n    /// @notice Encode hash of the zkSync native transaction type.\n    /// @return keccak256 hash of the EIP-712 encoded representation of transaction\n    function _encodeHashEIP712Transaction(Transaction calldata _transaction) private view returns (bytes32) {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                EIP712_TRANSACTION_TYPE_HASH,\n                _transaction.txType,\n                _transaction.from,\n                _transaction.to,\n                _transaction.gasLimit,\n                _transaction.gasPerPubdataByteLimit,\n                _transaction.maxFeePerGas,\n                _transaction.maxPriorityFeePerGas,\n                _transaction.paymaster,\n                _transaction.nonce,\n                _transaction.value,\n                EfficientCall.keccak(_transaction.data),\n                keccak256(abi.encodePacked(_transaction.factoryDeps)),\n                EfficientCall.keccak(_transaction.paymasterInput)\n            )\n        );\n\n        bytes32 domainSeparator = keccak256(\n            abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(\"zkSync\"), keccak256(\"2\"), block.chainid)\n        );\n\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n\n    /// @notice Encode hash of the legacy transaction type.\n    /// @return keccak256 of the serialized RLP encoded representation of transaction\n    function _encodeHashLegacyTransaction(Transaction calldata _transaction) private view returns (bytes32) {\n        // Hash of legacy transactions are encoded as one of the:\n        // - RLP(nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0)\n        // - RLP(nonce, gasPrice, gasLimit, to, value, data)\n        //\n        // In this RLP encoding, only the first one above list appears, so we encode each element\n        // inside list and then concatenate the length of all elements with them.\n\n        bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n        // Encode `gasPrice` and `gasLimit` together to prevent \"stack too deep error\".\n        bytes memory encodedGasParam;\n        {\n            bytes memory encodedGasPrice = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            encodedGasParam = bytes.concat(encodedGasPrice, encodedGasLimit);\n        }\n\n        bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n        bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // Encode `chainId` according to EIP-155, but only if the `chainId` is specified in the transaction.\n        bytes memory encodedChainId;\n        if (_transaction.reserved[0] != 0) {\n            encodedChainId = bytes.concat(RLPEncoder.encodeUint256(block.chainid), hex\"80_80\");\n        }\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedNonce.length +\n                encodedGasParam.length +\n                encodedTo.length +\n                encodedValue.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedChainId.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    encodedListLength,\n                    encodedNonce,\n                    encodedGasParam,\n                    encodedTo,\n                    encodedValue,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedChainId\n                )\n            );\n    }\n\n    /// @notice Encode hash of the EIP2930 transaction type.\n    /// @return keccak256 of the serialized RLP encoded representation of transaction\n    function _encodeHashEIP2930Transaction(Transaction calldata _transaction) private view returns (bytes32) {\n        // Hash of EIP2930 transactions is encoded the following way:\n        // H(0x01 || RLP(chain_id, nonce, gas_price, gas_limit, destination, amount, data, access_list))\n        //\n        // Note, that on zkSync access lists are not supported and should always be empty.\n\n        // Encode all fixed-length params to avoid \"stack too deep error\"\n        bytes memory encodedFixedLengthParams;\n        {\n            bytes memory encodedChainId = RLPEncoder.encodeUint256(block.chainid);\n            bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n            bytes memory encodedGasPrice = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n            bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n            encodedFixedLengthParams = bytes.concat(\n                encodedChainId,\n                encodedNonce,\n                encodedGasPrice,\n                encodedGasLimit,\n                encodedTo,\n                encodedValue\n            );\n        }\n\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // On zkSync, access lists are always zero length (at least for now).\n        bytes memory encodedAccessListLength = RLPEncoder.encodeListLen(0);\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedFixedLengthParams.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedAccessListLength.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    \"\\x01\",\n                    encodedListLength,\n                    encodedFixedLengthParams,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedAccessListLength\n                )\n            );\n    }\n\n    /// @notice Encode hash of the EIP1559 transaction type.\n    /// @return keccak256 of the serialized RLP encoded representation of transaction\n    function _encodeHashEIP1559Transaction(Transaction calldata _transaction) private view returns (bytes32) {\n        // Hash of EIP1559 transactions is encoded the following way:\n        // H(0x02 || RLP(chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list))\n        //\n        // Note, that on zkSync access lists are not supported and should always be empty.\n\n        // Encode all fixed-length params to avoid \"stack too deep error\"\n        bytes memory encodedFixedLengthParams;\n        {\n            bytes memory encodedChainId = RLPEncoder.encodeUint256(block.chainid);\n            bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n            bytes memory encodedMaxPriorityFeePerGas = RLPEncoder.encodeUint256(_transaction.maxPriorityFeePerGas);\n            bytes memory encodedMaxFeePerGas = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n            bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n            encodedFixedLengthParams = bytes.concat(\n                encodedChainId,\n                encodedNonce,\n                encodedMaxPriorityFeePerGas,\n                encodedMaxFeePerGas,\n                encodedGasLimit,\n                encodedTo,\n                encodedValue\n            );\n        }\n\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // On zkSync, access lists are always zero length (at least for now).\n        bytes memory encodedAccessListLength = RLPEncoder.encodeListLen(0);\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedFixedLengthParams.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedAccessListLength.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    \"\\x02\",\n                    encodedListLength,\n                    encodedFixedLengthParams,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedAccessListLength\n                )\n            );\n    }\n\n    /// @notice Processes the common paymaster flows, e.g. setting proper allowance\n    /// for tokens, etc. For more information on the expected behavior, check out\n    /// the \"Paymaster flows\" section in the documentation.\n    function processPaymasterInput(Transaction calldata _transaction) internal {\n        require(_transaction.paymasterInput.length >= 4, \"The standard paymaster input must be at least 4 bytes long\");\n\n        bytes4 paymasterInputSelector = bytes4(_transaction.paymasterInput[0:4]);\n        if (paymasterInputSelector == IPaymasterFlow.approvalBased.selector) {\n            require(\n                _transaction.paymasterInput.length >= 68,\n                \"The approvalBased paymaster input must be at least 68 bytes long\"\n            );\n\n            // While the actual data consists of address, uint256 and bytes data,\n            // the data is needed only for the paymaster, so we ignore it here for the sake of optimization\n            (address token, uint256 minAllowance) = abi.decode(_transaction.paymasterInput[4:68], (address, uint256));\n            address paymaster = address(uint160(_transaction.paymaster));\n\n            uint256 currentAllowance = IERC20(token).allowance(address(this), paymaster);\n            if (currentAllowance < minAllowance) {\n                // Some tokens, e.g. USDT require that the allowance is firsty set to zero\n                // and only then updated to the new value.\n\n                IERC20(token).safeApprove(paymaster, 0);\n                IERC20(token).safeApprove(paymaster, minAllowance);\n            }\n        } else if (paymasterInputSelector == IPaymasterFlow.general.selector) {\n            // Do nothing. general(bytes) paymaster flow means that the paymaster must interpret these bytes on his own.\n        } else {\n            revert(\"Unsupported paymaster flow\");\n        }\n    }\n\n    /// @notice Pays the required fee for the transaction to the bootloader.\n    /// @dev Currently it pays the maximum amount \"_transaction.maxFeePerGas * _transaction.gasLimit\",\n    /// it will change in the future.\n    function payToTheBootloader(Transaction calldata _transaction) internal returns (bool success) {\n        address bootloaderAddr = BOOTLOADER_FORMAL_ADDRESS;\n        uint256 amount = _transaction.maxFeePerGas * _transaction.gasLimit;\n\n        assembly {\n            success := call(gas(), bootloaderAddr, amount, 0, 0, 0, 0)\n        }\n    }\n\n    // Returns the balance required to process the transaction.\n    function totalRequiredBalance(Transaction calldata _transaction) internal pure returns (uint256 requiredBalance) {\n        if (address(uint160(_transaction.paymaster)) != address(0)) {\n            // Paymaster pays for the fee\n            requiredBalance = _transaction.value;\n        } else {\n            // The user should have enough balance for both the fee and the value of the transaction\n            requiredBalance = _transaction.maxFeePerGas * _transaction.gasLimit + _transaction.value;\n        }\n    }\n}\n\n\n\n\n\n\nenum ExecutionResult {\n    Revert,\n    Success\n}\n\nbytes4 constant PAYMASTER_VALIDATION_SUCCESS_MAGIC = IPaymaster.validateAndPayForPaymasterTransaction.selector;\n\ninterface IPaymaster {\n    /// @dev Called by the bootloader to verify that the paymaster agrees to pay for the\n    /// fee for the transaction. This transaction should also send the necessary amount of funds onto the bootloader\n    /// address.\n    /// @param _txHash The hash of the transaction\n    /// @param _suggestedSignedHash The hash of the transaction that is signed by an EOA\n    /// @param _transaction The transaction itself.\n    /// @return magic The value that should be equal to the signature of the validateAndPayForPaymasterTransaction\n    /// if the paymaster agrees to pay for the transaction.\n    /// @return context The \"context\" of the transaction: an array of bytes of length at most 1024 bytes, which will be\n    /// passed to the `postTransaction` method of the account.\n    /// @dev The developer should strive to preserve as many steps as possible both for valid\n    /// and invalid transactions as this very method is also used during the gas fee estimation\n    /// (without some of the necessary data, e.g. signature).\n    function validateAndPayForPaymasterTransaction(\n        bytes32 _txHash,\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) external payable returns (bytes4 magic, bytes memory context);\n\n    /// @dev Called by the bootloader after the execution of the transaction. Please note that\n    /// there is no guarantee that this method will be called at all. Unlike the original EIP4337,\n    /// this method won't be called if the transaction execution results in out-of-gas.\n    /// @param _context, the context of the execution, returned by the \"validateAndPayForPaymasterTransaction\" method.\n    /// @param  _transaction, the users' transaction.\n    /// @param _txResult, the result of the transaction execution (success or failure).\n    /// @param _maxRefundedGas, the upper bound on the amout of gas that could be refunded to the paymaster.\n    /// @dev The exact amount refunded depends on the gas spent by the \"postOp\" itself and so the developers should\n    /// take that into account.\n    function postTransaction(\n        bytes calldata _context,\n        Transaction calldata _transaction,\n        bytes32 _txHash,\n        bytes32 _suggestedSignedHash,\n        ExecutionResult _txResult,\n        uint256 _maxRefundedGas\n    ) external payable;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//import {TransactionHelper, Transaction} from \"@matterlabs/zksync-contracts/l2/system-contracts/libraries/TransactionHelper.sol\";\n//already imported above\n//import \"@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol\";\n//inside below\n//import \"./interfaces/IAccountCodeStorage.sol\";\n\ninterface IAccountCodeStorage {\n    function storeAccountConstructingCodeHash(address _address, bytes32 _hash) external;\n\n    function storeAccountConstructedCodeHash(address _address, bytes32 _hash) external;\n\n    function markAccountCodeHashAsConstructed(address _address) external;\n\n    function getRawCodeHash(address _address) external view returns (bytes32 codeHash);\n\n    function getCodeHash(uint256 _input) external view returns (bytes32 codeHash);\n\n    function getCodeSize(uint256 _input) external view returns (uint256 codeSize);\n}\n\n//import \"./interfaces/INonceHolder.sol\";\ninterface INonceHolder {\n    event ValueSetUnderNonce(address indexed accountAddress, uint256 indexed key, uint256 value);\n\n    /// @dev Returns the current minimal nonce for account.\n    function getMinNonce(address _address) external view returns (uint256);\n\n    /// @dev Returns the raw version of the current minimal nonce\n    /// (equal to minNonce + 2^128 * deployment nonce).\n    function getRawNonce(address _address) external view returns (uint256);\n\n    /// @dev Increases the minimal nonce for the msg.sender.\n    function increaseMinNonce(uint256 _value) external returns (uint256);\n\n    /// @dev Sets the nonce value `key` as used.\n    function setValueUnderNonce(uint256 _key, uint256 _value) external;\n\n    /// @dev Gets the value stored inside a custom nonce.\n    function getValueUnderNonce(uint256 _key) external view returns (uint256);\n\n    /// @dev A convenience method to increment the minimal nonce if it is equal\n    /// to the `_expectedNonce`.\n    function incrementMinNonceIfEquals(uint256 _expectedNonce) external;\n\n    /// @dev Returns the deployment nonce for the accounts used for CREATE opcode.\n    function getDeploymentNonce(address _address) external view returns (uint256);\n\n    /// @dev Increments the deployment nonce for the account and returns the previous one.\n    function incrementDeploymentNonce(address _address) external returns (uint256);\n\n    /// @dev Determines whether a certain nonce has been already used for an account.\n    function validateNonceUsage(address _address, uint256 _key, bool _shouldBeUsed) external view;\n\n    /// @dev Returns whether a nonce has been used for an account.\n    function isNonceUsed(address _address, uint256 _nonce) external view returns (bool);\n}\n\n\n//import \"./interfaces/IKnownCodesStorage.sol\";\ninterface IKnownCodesStorage {\n    event MarkedAsKnown(bytes32 indexed bytecodeHash, bool indexed sendBytecodeToL1);\n\n    function markFactoryDeps(bool _shouldSendToL1, bytes32[] calldata _hashes) external;\n\n    function markBytecodeAsPublished(\n        bytes32 _bytecodeHash,\n        bytes32 _l1PreimageHash,\n        uint256 _l1PreimageBytesLen\n    ) external;\n\n    function getMarker(bytes32 _hash) external view returns (uint256);\n}\n\n//import \"./interfaces/IImmutableSimulator.sol\";\nstruct ImmutableData {\n    uint256 index;\n    bytes32 value;\n}\n\ninterface IImmutableSimulator {\n    function getImmutable(address _dest, uint256 _index) external view returns (bytes32);\n\n    function setImmutables(address _dest, ImmutableData[] calldata _immutables) external;\n}\n\n//import \"./interfaces/IL1Messenger.sol\";\n\ninterface IL1Messenger {\n    // Possibly in the future we will be able to track the messages sent to L1 with\n    // some hooks in the VM. For now, it is much easier to track them with L2 events.\n    event L1MessageSent(address indexed _sender, bytes32 indexed _hash, bytes _message);\n\n    function sendToL1(bytes memory _message) external returns (bytes32);\n}\n\n//import \"./interfaces/ISystemContext.sol\";\ninterface ISystemContext {\n    function chainId() external view returns (uint256);\n\n    function origin() external view returns (address);\n\n    function gasPrice() external view returns (uint256);\n\n    function blockGasLimit() external view returns (uint256);\n\n    function coinbase() external view returns (address);\n\n    function difficulty() external view returns (uint256);\n\n    function baseFee() external view returns (uint256);\n\n    function blockHash(uint256 _block) external view returns (bytes32);\n\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32);\n\n    function getBlockNumberAndTimestamp() external view returns (uint256 blockNumber, uint256 blockTimestamp);\n\n    // Note, that for now, the implementation of the bootloader allows this variables to\n    // be incremented multiple times inside a block, so it should not relied upon right now.\n    function getBlockNumber() external view returns (uint256);\n\n    function getBlockTimestamp() external view returns (uint256);\n}\n\n//import \"./interfaces/IBytecodeCompressor.sol\";\ninterface IBytecodeCompressor {\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable returns (bytes32 bytecodeHash);\n}\n\n//import \"./BootloaderUtilities.sol\";\n\n//import \"../libraries/TransactionHelper.sol\"; already imported\n\ninterface IBootloaderUtilities {\n    function getTransactionHashes(\n        Transaction calldata _transaction\n    ) external view returns (bytes32 txHash, bytes32 signedTxHash);\n}\n\n/// @dev All the system contracts introduced by zkSync have their addresses\n/// started from 2^15 in order to avoid collision with Ethereum precompiles.\n\n/// @dev All the system contracts must be located in the kernel space,\n/// i.e. their addresses must be below 2^16.\n\naddress constant ECRECOVER_SYSTEM_CONTRACT = address(0x01);\n\n/// @dev The current maximum deployed precompile address.\n/// Note: currently only two precompiles are deployed:\n/// 0x01 - ecrecover\n/// 0x02 - sha256\n/// Important! So the constant should be updated if more precompiles are deployed.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(SHA256_SYSTEM_CONTRACT));\n\nIAccountCodeStorage constant ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT = IAccountCodeStorage(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x02)\n);\nINonceHolder constant NONCE_HOLDER_SYSTEM_CONTRACT = INonceHolder(address(SYSTEM_CONTRACTS_OFFSET + 0x03));\nIKnownCodesStorage constant KNOWN_CODE_STORAGE_CONTRACT = IKnownCodesStorage(address(SYSTEM_CONTRACTS_OFFSET + 0x04));\nIImmutableSimulator constant IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT = IImmutableSimulator(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x05)\n);\nIContractDeployer constant DEPLOYER_SYSTEM_CONTRACT = IContractDeployer(address(SYSTEM_CONTRACTS_OFFSET + 0x06));\n\n// A contract that is allowed to deploy any codehash\n// on any address. To be used only during an upgrade.\naddress constant FORCE_DEPLOYER = address(SYSTEM_CONTRACTS_OFFSET + 0x07);\nIL1Messenger constant L1_MESSENGER_CONTRACT = IL1Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\n\n\n\nISystemContext constant SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(SYSTEM_CONTRACTS_OFFSET + 0x0b)));\n//load bootloaderutilites\n\npragma solidity ^0.8.0;\n\n//import \"./interfaces/IBootloaderUtilities.sol\"; already loaded\n//import \"./libraries/TransactionHelper.sol\"; already loaded\n//import \"./libraries/RLPEncoder.sol\"; already loaded\n//import \"./libraries/EfficientCall.sol\"; already loaded\n\n/**\n * @author Matter Labs\n * @notice A contract that provides some utility methods for the bootloader\n * that is very hard to write in Yul.\n */\ncontract BootloaderUtilities is IBootloaderUtilities {\n    using TransactionHelper for *;\n\n    /// @notice Calculates the canonical transaction hash and the recommended transaction hash.\n    /// @param _transaction The transaction.\n    /// @return txHash and signedTxHash of the transaction, i.e. the transaction hash to be used in the explorer and commits to all\n    /// the fields of the transaction and the recommended hash to be signed for this transaction.\n    /// @dev txHash must be unique for all transactions.\n    function getTransactionHashes(\n        Transaction calldata _transaction\n    ) external view override returns (bytes32 txHash, bytes32 signedTxHash) {\n        signedTxHash = _transaction.encodeHash();\n        if (_transaction.txType == EIP_712_TX_TYPE) {\n            txHash = keccak256(bytes.concat(signedTxHash, EfficientCall.keccak(_transaction.signature)));\n        } else if (_transaction.txType == LEGACY_TX_TYPE) {\n            txHash = encodeLegacyTransactionHash(_transaction);\n        } else if (_transaction.txType == EIP_1559_TX_TYPE) {\n            txHash = encodeEIP1559TransactionHash(_transaction);\n        } else if (_transaction.txType == EIP_2930_TX_TYPE) {\n            txHash = encodeEIP2930TransactionHash(_transaction);\n        } else {\n            revert(\"Unsupported tx type\");\n        }\n    }\n\n    /// @notice Calculates the hash for a legacy transaction.\n    /// @param _transaction The legacy transaction.\n    /// @return txHash The hash of the transaction.\n    function encodeLegacyTransactionHash(Transaction calldata _transaction) internal view returns (bytes32 txHash) {\n        // Hash of legacy transactions are encoded as one of the:\n        // - RLP(nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0)\n        // - RLP(nonce, gasPrice, gasLimit, to, value, data)\n        //\n        // In this RLP encoding, only the first one above list appears, so we encode each element\n        // inside list and then concatenate the length of all elements with them.\n\n        bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n        // Encode `gasPrice` and `gasLimit` together to prevent \"stack too deep error\".\n        bytes memory encodedGasParam;\n        {\n            bytes memory encodedGasPrice = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            encodedGasParam = bytes.concat(encodedGasPrice, encodedGasLimit);\n        }\n\n        bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n        bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        bytes memory rEncoded;\n        {\n            uint256 rInt = uint256(bytes32(_transaction.signature[0:32]));\n            rEncoded = RLPEncoder.encodeUint256(rInt);\n        }\n        bytes memory sEncoded;\n        {\n            uint256 sInt = uint256(bytes32(_transaction.signature[32:64]));\n            sEncoded = RLPEncoder.encodeUint256(sInt);\n        }\n        bytes memory vEncoded;\n        {\n            uint256 vInt = uint256(uint8(_transaction.signature[64]));\n            require(vInt == 27 || vInt == 28, \"Invalid v value\");\n\n            // If the `chainId` is specified in the transaction, then the `v` value is encoded as\n            // `35 + y + 2 * chainId == vInt + 8 + 2 * chainId`, where y - parity bit (see EIP-155).\n            if (_transaction.reserved[0] != 0) {\n                vInt += 8 + block.chainid * 2;\n            }\n\n            vEncoded = RLPEncoder.encodeUint256(vInt);\n        }\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedNonce.length +\n                encodedGasParam.length +\n                encodedTo.length +\n                encodedValue.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                rEncoded.length +\n                sEncoded.length +\n                vEncoded.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    encodedListLength,\n                    encodedNonce,\n                    encodedGasParam,\n                    encodedTo,\n                    encodedValue,\n                    encodedDataLength,\n                    _transaction.data,\n                    vEncoded,\n                    rEncoded,\n                    sEncoded\n                )\n            );\n    }\n\n    /// @notice Calculates the hash for an EIP2930 transaction.\n    /// @param _transaction The EIP2930 transaction.\n    /// @return txHash The hash of the transaction.\n    function encodeEIP2930TransactionHash(Transaction calldata _transaction) internal view returns (bytes32) {\n        // Encode all fixed-length params to avoid \"stack too deep error\"\n        bytes memory encodedFixedLengthParams;\n        {\n            bytes memory encodedChainId = RLPEncoder.encodeUint256(block.chainid);\n            bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n            bytes memory encodedGasPrice = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n            bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n            encodedFixedLengthParams = bytes.concat(\n                encodedChainId,\n                encodedNonce,\n                encodedGasPrice,\n                encodedGasLimit,\n                encodedTo,\n                encodedValue\n            );\n        }\n\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // On zkSync, access lists are always zero length (at least for now).\n        bytes memory encodedAccessListLength = RLPEncoder.encodeListLen(0);\n\n        bytes memory rEncoded;\n        {\n            uint256 rInt = uint256(bytes32(_transaction.signature[0:32]));\n            rEncoded = RLPEncoder.encodeUint256(rInt);\n        }\n        bytes memory sEncoded;\n        {\n            uint256 sInt = uint256(bytes32(_transaction.signature[32:64]));\n            sEncoded = RLPEncoder.encodeUint256(sInt);\n        }\n        bytes memory vEncoded;\n        {\n            uint256 vInt = uint256(uint8(_transaction.signature[64]));\n            require(vInt == 27 || vInt == 28, \"Invalid v value\");\n\n            vEncoded = RLPEncoder.encodeUint256(vInt - 27);\n        }\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedFixedLengthParams.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedAccessListLength.length +\n                rEncoded.length +\n                sEncoded.length +\n                vEncoded.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    \"\\x01\",\n                    encodedListLength,\n                    encodedFixedLengthParams,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedAccessListLength,\n                    vEncoded,\n                    rEncoded,\n                    sEncoded\n                )\n            );\n    }\n\n    /// @notice Calculates the hash for an EIP1559 transaction.\n    /// @param _transaction The legacy transaction.\n    /// @return txHash The hash of the transaction.\n    function encodeEIP1559TransactionHash(Transaction calldata _transaction) internal view returns (bytes32) {\n        // The formula for hash of EIP1559 transaction in the original proposal:\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md\n\n        // Encode all fixed-length params to avoid \"stack too deep error\"\n        bytes memory encodedFixedLengthParams;\n        {\n            bytes memory encodedChainId = RLPEncoder.encodeUint256(block.chainid);\n            bytes memory encodedNonce = RLPEncoder.encodeUint256(_transaction.nonce);\n            bytes memory encodedMaxPriorityFeePerGas = RLPEncoder.encodeUint256(_transaction.maxPriorityFeePerGas);\n            bytes memory encodedMaxFeePerGas = RLPEncoder.encodeUint256(_transaction.maxFeePerGas);\n            bytes memory encodedGasLimit = RLPEncoder.encodeUint256(_transaction.gasLimit);\n            bytes memory encodedTo = RLPEncoder.encodeAddress(address(uint160(_transaction.to)));\n            bytes memory encodedValue = RLPEncoder.encodeUint256(_transaction.value);\n            encodedFixedLengthParams = bytes.concat(\n                encodedChainId,\n                encodedNonce,\n                encodedMaxPriorityFeePerGas,\n                encodedMaxFeePerGas,\n                encodedGasLimit,\n                encodedTo,\n                encodedValue\n            );\n        }\n\n        // Encode only the length of the transaction data, and not the data itself,\n        // so as not to copy to memory a potentially huge transaction data twice.\n        bytes memory encodedDataLength;\n        {\n            // Safe cast, because the length of the transaction data can't be so large.\n            uint64 txDataLen = uint64(_transaction.data.length);\n            if (txDataLen != 1) {\n                // If the length is not equal to one, then only using the length can it be encoded definitely.\n                encodedDataLength = RLPEncoder.encodeNonSingleBytesLen(txDataLen);\n            } else if (_transaction.data[0] >= 0x80) {\n                // If input is a byte in [0x80, 0xff] range, RLP encoding will concatenates 0x81 with the byte.\n                encodedDataLength = hex\"81\";\n            }\n            // Otherwise the length is not encoded at all.\n        }\n\n        // On zkSync, access lists are always zero length (at least for now).\n        bytes memory encodedAccessListLength = RLPEncoder.encodeListLen(0);\n\n        bytes memory rEncoded;\n        {\n            uint256 rInt = uint256(bytes32(_transaction.signature[0:32]));\n            rEncoded = RLPEncoder.encodeUint256(rInt);\n        }\n        bytes memory sEncoded;\n        {\n            uint256 sInt = uint256(bytes32(_transaction.signature[32:64]));\n            sEncoded = RLPEncoder.encodeUint256(sInt);\n        }\n        bytes memory vEncoded;\n        {\n            uint256 vInt = uint256(uint8(_transaction.signature[64]));\n            require(vInt == 27 || vInt == 28, \"Invalid v value\");\n\n            vEncoded = RLPEncoder.encodeUint256(vInt - 27);\n        }\n\n        bytes memory encodedListLength;\n        unchecked {\n            uint256 listLength = encodedFixedLengthParams.length +\n                encodedDataLength.length +\n                _transaction.data.length +\n                encodedAccessListLength.length +\n                rEncoded.length +\n                sEncoded.length +\n                vEncoded.length;\n\n            // Safe cast, because the length of the list can't be so large.\n            encodedListLength = RLPEncoder.encodeListLen(uint64(listLength));\n        }\n\n        return\n            keccak256(\n                bytes.concat(\n                    \"\\x02\",\n                    encodedListLength,\n                    encodedFixedLengthParams,\n                    encodedDataLength,\n                    _transaction.data,\n                    encodedAccessListLength,\n                    vEncoded,\n                    rEncoded,\n                    sEncoded\n                )\n            );\n    }\n}\n\nBootloaderUtilities constant BOOTLOADER_UTILITIES = BootloaderUtilities(address(SYSTEM_CONTRACTS_OFFSET + 0x0c));\n\naddress constant EVENT_WRITER_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x0d);\n\nIBytecodeCompressor constant BYTECODE_COMPRESSOR_CONTRACT = IBytecodeCompressor(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x0e)\n);\n\n\n/// @dev The maximal msg.value that context can have\nuint256 constant MAX_MSG_VALUE = 2 ** 128 - 1;\n\n/// @dev Prefix used during derivation of account addresses using CREATE2\n/// @dev keccak256(\"zksyncCreate2\")\nbytes32 constant CREATE2_PREFIX = 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494;\n/// @dev Prefix used during derivation of account addresses using CREATE\n/// @dev keccak256(\"zksyncCreate\")\nbytes32 constant CREATE_PREFIX = 0x63bae3a9951d38e8a3fbb7b70909afc1200610fc5bc55ade242f815974674f23;\n\n\n\n\n// Define the TokenAmount struct\nstruct TokenAmount {\n    address token;     // Address of the token\n    uint256 amount;    // Amount of the token\n}\n\n// Define the SwapStep struct\nstruct SwapStep {\n    address pool;          // Address of the liquidity pool\n    bytes data;           // Additional data for the swap\n    address callback;      // Address for the callback function\n    bytes callbackData;    // Data for the callback function\n}\n\n// Define the SwapPath struct\nstruct SwapPath {\n    SwapStep[] steps;     // Array of swap steps\n    address tokenIn;      // Address of the input token\n    uint256 amountIn;     // Amount of the input token\n}\n\ninterface IRouter {\n    /**\n     * @dev Performs a swap.\n     * @param paths The array of swap paths.\n     * @param amountOutMin The minimum amount of output tokens to receive.\n     * @param deadline The time by which the swap must be completed.\n     * @return amountOut The amount of output tokens received.\n     */\n    function swap(\n        SwapPath[] memory paths,\n        uint256 amountOutMin,\n        uint256 deadline\n    ) external payable returns (TokenAmount memory amountOut);\n    \n    \n}\n\n\n\n\ninterface zkBitcoin2 {\n    function mintTo(uint256 nonce, address mintToAddress) external;\n    function multiMint_SameAddress(address mintToAddress, uint256[] memory nonce) external;\n    function getMiningReward() external view returns (uint);\n    function blocksToReadjust() external view returns (uint blocks);\n}\n\n\ninterface Paymaster2 {\n    \tfunction NumberofMints() external view returns (uint);\n    \tfunction AddressToUse() external view returns (address);\n        function PoolContract_Mint_No_Paymaster(uint256[] memory nonce) external;\n        function MultiMint_Paymaster(uint256[] memory nonce, uint nonceLength, uint requiredZKBTCz) external;\n \tfunction estimateGas_Paymaster(uint256[] memory nonce, uint nonceLength) external;\n \tfunction withdrawERC20(address token, uint256 amount) external;\n \tfunction withdrawERC721(address token, uint256 tokenId) external;\n \tfunction withdrawERC1155(address token, uint256 tokenId, uint256 amount, bytes calldata data) external;\n\tfunction withdrawETH(uint256 amount) external;\n}\n\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\n}\n\n\n\n\ncontract zkBitcoin_Paymaster is IPaymaster {\n\n\n    mapping(address=>address) public AllowedToUsePaymaster;\n    mapping(address=>bool) public mintedETH;\n\n    address public constant allowedToken = 0x366d17aDB24A7654DbE82e79F85F9Cb03c03cD0D; //Mainnet = 0x366d17aDB24A7654DbE82e79F85F9Cb03c03cD0D //Testnet = 0xC298c19a01F5c13d38d7116849bB09cc9646314E\n    //address public constant WETH = 0x000000000000000000000000000000000000800A; // Wrapped ETH address\n    address public constant pairAddress = 0x7002d33C756f593AB41aF4a236005766E80dC960;  //Mainnet = 0x7002d33C756f593AB41aF4a236005766E80dC960 //Testnet = 0x14E3373CaD5a5c98D43a3d7AE6284B8c8255bCc7\n    address public constant zeroAddress = address(0);\n    address public constant IrouterAddress = 0x9B5def958d0f3b6955cBEa4D5B7809b2fb26b059;  //Mainnet = 0x9B5def958d0f3b6955cBEa4D5B7809b2fb26b059  //Testnet = 0x3f39129e54d2331926c1E4bf034e111cf471AA97\n\n    address public mainWithdrawler = msg.sender; // Address to withdraw Paymaster zkBTC to\n    address public mainUpdater = msg.sender; // Address to Update Token Price\n    address public owner = msg.sender;  //Main contract owner\n    address public mainDiscounter = msg.sender; //Address to update discount\n    uint public TokenPrice = getPriceX();\n    \n     //If under 10 good blocks add GasBuffer if 10 good blocks and over add GasBuffer2\n    uint public goodLoopsGasExtra=10;\n\n    //30% discount for using Paymaster\n    uint public discount=30;\n\n////\n//PayMaster Stuff First then Minting\n////\n    \n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n    \n    \n    function setGoodLoopsGasExtra (uint256 extraLoops)public onlyOwner {\n\t    goodLoopsGasExtra = extraLoops;\n    }\n    \n    \n    \n\n    function setDiscount(uint _discount) public onlyDiscounter {\n    \trequire(_discount<90,\"Max discount is 90%\");\n    \tdiscount = _discount;\n    }\n    \n    \n    function getDiscount ()public view returns (uint) {\n\t    return discount;\n    }\n    \n    \n    function setMainDiscounter(address _mainDiscounter) public onlyDiscounter {\n    \tmainDiscounter = _mainDiscounter;\n    }\n    \n    function setMainWithdrawler(address _mainWithdrawler) public onlyMainWithdrawler {\n    \tmainWithdrawler = _mainWithdrawler;\n    }\n    \n    function setMainUpdater(address _mainUpdater) public onlyMainUpdater {\n    \tmainUpdater = _mainUpdater;\n    }\n    \n    function setTokenPrice() public onlyMainUpdater {\n    \tTokenPrice = getPriceX();\n    }\n    \n    \n    function withdrawAll(uint amountETH, uint amountZKBTCF) public onlyMainWithdrawler {\n    \tIERC20(allowedToken).transfer(mainWithdrawler, amountZKBTCF);\n    \trequire(address(this).balance >= amountETH, \"Insufficient balance in contract\");\n        // Transfer ETH\n        (bool sent, ) = mainWithdrawler.call{value: amountETH}(\"\");\n        require(sent, \"Failed to send ETH\");\n    }\n    \n    function withdrawETH(uint amountETH) public onlyMainWithdrawler {\n    \trequire(address(this).balance >= amountETH, \"Insufficient balance in contract\");\n        // Transfer ETH\n        (bool sent, ) = mainWithdrawler.call{value: amountETH}(\"\");\n        require(sent, \"Failed to send ETH\");\n    }\n    \n    function withdrawToken(address Token_addy, uint amountTOKEN) public onlyMainWithdrawler {\n    \tIERC20(Token_addy).transfer(mainWithdrawler, amountTOKEN);\n    \t\n    }\n    \n    \n    function getMainWithdrawler() public view returns (address) {\n    \treturn mainWithdrawler;\n    }\n    \n    function getMainUpdater() public view returns (address) {\n    \treturn mainUpdater;\n    }\n    \n    \n    \n    \n    function getGoodLoopsGasExtra  ()public view returns (uint) {\n\t    return goodLoopsGasExtra;\n    }\n    \n    // Returns the price of `token` in terms of ETH x1000\n    function  getPriceX() public view returns (uint) {\n\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n        (uint tokenReserves, uint ethReserves) = pair.getReserves();\n\n        // Ensure that reserves are returned in the correct order (token, WETH) Extra gas skip it calling WETH contract.\n        //(uint reserves0, uint reserves1) = pair.getReserves();\n        //(uint tokenReserves, uint ethReserves) = address(this) < WETH ? (reserves0, reserves1) : (reserves1, reserves0);\n\t\n\t\n        return (tokenReserves * 10**3) / ethReserves; // Normalize to token's decimals if necessary\n    }\n    \n    modifier onlyMainWithdrawler() {\n        require(msg.sender == mainWithdrawler || owner == msg.sender, \"only mainWithdrawler/owner can call this function\");\n        _;\n    }\n    modifier onlyMainUpdater() {\n        require(msg.sender == mainUpdater || owner == msg.sender, \"only mainUpdater/owner can call this function\");\n        _;\n    }\n    \n    modifier onlyDiscounter() {\n        require(msg.sender == mainDiscounter || owner == msg.sender, \"only mainUpdater/owner can call this function\");\n        _;\n    }\n\n    modifier onlyBootloader() {\n        require(\n            msg.sender == BOOTLOADER_FORMAL_ADDRESS,\n            \"Only bootloader can call this method\"\n        );\n        // Continue execution if called from the bootloader.\n        _;\n    }    \n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n    \n    function validateAndPayForPaymasterTransaction(\n    bytes32,\n    bytes32,\n    Transaction calldata _transaction\n)\n    external\n    payable\n    onlyBootloader\n    returns (bytes4 magic, bytes memory context)\n\n{\n\n    magic = PAYMASTER_VALIDATION_SUCCESS_MAGIC;\n    require(\n        _transaction.paymasterInput.length >= 4,\n        \"The standard paymaster input must be at least 4 bytes long\"\n    );\n    bytes4 paymasterInputSelector = bytes4(_transaction.paymasterInput[0:4]);\n    if (paymasterInputSelector == IPaymasterFlow.approvalBased.selector) {\n        address whoSentTx =  address(uint160(_transaction.from));\n        require(address(this) == address(uint160(_transaction.to)), \"Must only send Paymaster Transaction to THIS address, cant use any other address\");\n        \n        \n        bytes4 functionSelector = bytes4(_transaction.data[:4]);\n        require(functionSelector == 0x62344a13, \"MUst be the correct function, we only are allowed to call the MultiMint_Paymaster function on this contract\");\n        address mintToAddress;\n        uint256[] memory nonce;\n        uint mintsgreaterthan25 = 0;\n        \n        (mintToAddress, nonce) = abi.decode(_transaction.data[4:], (address, uint256[]));\n\tuint nonceLength = nonce.length;\n\tuint256 requiredETH = _transaction.gasLimit * _transaction.maxFeePerGas;\n\n        uint price = TokenPrice;\n        uint curPrice = getPriceX();\n        //Allows token price to fall and stay correct\n        if(price < curPrice){\n        \tprice = curPrice;\n        }\n        uint totalZKBTC = (requiredETH * price) / (10**3);\n\n\n\tuint256 blocksToReadjustment = zkBitcoin2(allowedToken).blocksToReadjust();\n\tif(blocksToReadjustment < nonceLength){\n\t\tnonceLength = blocksToReadjustment;\n\t}\n\tuint buffer = 100;\n\taddress WhatSubContractToUse = AllowedToUsePaymaster[mintToAddress];\n\tif(WhatSubContractToUse != address(0)){\n\t\tPaymaster2(WhatSubContractToUse).MultiMint_Paymaster(nonce, nonceLength, totalZKBTC);\n\t\tmintsgreaterthan25 = External_NumberOfMints(whoSentTx);\n\t\ttotalZKBTC = totalZKBTC * (100 - discount) / 100;  //Discount mints 30% about to start but not the first one!\n\t}\n\telse{\n\t\tdeployNewContract(whoSentTx);\n\t\tfor(uint xx=0; xx<nonceLength; xx++){\n\t\t\tzkBitcoin2(allowedToken).mintTo(nonce[xx], address(this));\n\t\t}\n\t\tbuffer = buffer + 100;\n\t}\n\n\t\n        \n\tuint rewardAmtz = zkBitcoin2(allowedToken).getMiningReward();\n\tuint mintAmount = nonceLength * rewardAmtz;\n\n\n\n\t//SET TO 10 to start for easy testing, should test it to 100\n\t//if(mintsgreaterthan25 > 100 && mintedETH[whoSentTx] == false ){\n\tif(mintsgreaterthan25 > 25 && mintedETH[WhatSubContractToUse] == false && whoSentTx == mintToAddress ){\n\n\t\t\tmintedETH[WhatSubContractToUse] = true;\n\t\t\tuint sendAmount = mintAmount - totalZKBTC;\n\t\t\tuint timeStampz = block.timestamp + 120;\n\t\t\tperformSwap(sendAmount, allowedToken, mintToAddress, 0, timeStampz);\n\t\t\ttotalZKBTC = totalZKBTC * 100 / (100 - discount); //No discounts when doing a swap one.\n\t\t\tbuffer = buffer + 150;\n\n\t\t\n\t}else{\n\t\t\n\t\tIERC20(allowedToken).transfer(mintToAddress, mintAmount - totalZKBTC);\n\t}\n\t\n\tif(goodLoopsGasExtra > nonceLength){\n\t\tbuffer = buffer + 100;\n\t}\n\trequire(gasleft() > buffer * _transaction.gasLimit / 1000,\"Not enough gas for transaction , most likely not enough gas provided\");\n\t    \n   \t(bool success, ) = payable(BOOTLOADER_FORMAL_ADDRESS).call{value: requiredETH}(\"\");\n        require(success, \"Failed to transfer tx fee to the bootloader. Paymaster balance might not be enough gas provided\");\n\t    \n       } else {\n        revert(\"Unsupported paymaster flow\");\n    }\n}\n\n    \n\n    function postTransaction(\n        bytes calldata _context,\n        Transaction calldata _transaction,\n        bytes32,\n        bytes32,\n        ExecutionResult _txResult,\n        uint256 _maxRefundedGas\n    ) external payable override onlyBootloader { \n    \t//Post Transaction code here\n    \n    }\n   \n\n\n      function performSwap(uint tokenAmountIn, address tokenIn2, address userAccount, uint256 amountOutMin, uint256 deadline) internal {\n        // Approve the token for the router\n        IERC20(tokenIn2).approve(IrouterAddress, tokenAmountIn);\n        \n        // Create encoded data\n        bytes memory encodedData = abi.encode(tokenIn2, userAccount, 1); // 1 signals ETH payout.\n\tSwapStep[] memory employee = new SwapStep[](1);\n\temployee[0].pool = pairAddress;\n\temployee[0].data = encodedData; \n\temployee[0].callback = zeroAddress;\n\temployee[0].callbackData = new bytes(0);\n\n\n        // Create a SwapPath instance\n        \n\tSwapPath[] memory employee22 = new SwapPath[](1);\n        employee22[0].steps = employee;\n        employee22[0].tokenIn = tokenIn2;\n        employee22[0].amountIn = tokenAmountIn;\n        \n        \n        // Call the swap function\n        IRouter(IrouterAddress).swap(employee22, 0, deadline);\n    }\n\n    \n    \n    \n\t\n\t\n\t// Function to deploy a new contract and store its address\n\tfunction deployNewContract(address sender) public {\n\t\t// Deploy the new contract\n    \t\trequire(AllowedToUsePaymaster[sender] == address(0), \"Must not already have a contract to use\");\n\n\t\tPaymasterZKBitcoin_Pool newContract = new PaymasterZKBitcoin_Pool(allowedToken, address(this), sender);\n        \n\t\t// Store the address of the newly deployed contract\n\t\taddress deployedContractAddress = address(newContract);\n\t\tAllowedToUsePaymaster[sender] = deployedContractAddress;\n\t}\n\n\tfunction YourPaymasterAddress(address userAddress) public view returns (address){\n\t\treturn AllowedToUsePaymaster[userAddress];\n\t\n\t}\n\t\n\t//For use in estimateing Gas, this will either \n\t//A) Deploy you a new Pool contract if one hasnt been deployed while submitting answers to this contract. \n\t//B) Submit your answers to the Pool contract to test parameters and figure out approxemently around how much gas we will use\n\t//ALL minted tokens in estimateGas are used to pay the Paymaster, you wont recieve any by calling this function because its just to test estimateGas.\n\t\n\t\n\tfunction estimateGas(address userAddress, uint[] memory nonces) public returns (bool){\n\t\n\t\n\t\tuint nonceLength = nonces.length;\n\t\t\n\t\tuint256 blocksToReadjustment = zkBitcoin2(allowedToken).blocksToReadjust();\n\t\tif(blocksToReadjustment < nonceLength){\n\t\t\tnonceLength = blocksToReadjustment;\n\t\t}\n\t\t\n\t\n\t\n\t\taddress WhatSubContractToUse = AllowedToUsePaymaster[userAddress];\n\t\tif(WhatSubContractToUse != address(0)){\n\t\t\tPaymaster2(WhatSubContractToUse).estimateGas_Paymaster(nonces, nonceLength);\n\t\t}\n\t\telse{\n\t\t\tdeployNewContract(userAddress);\n\t\t\tfor(uint xx=0; xx<nonceLength; xx++){\n\t\t\t\tzkBitcoin2(allowedToken).mintTo(nonces[xx], address(this));\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t//Allows users to MultiMint to their contract without the Paymaster, keeping their mining contracts working forever!.\n\t\n\tfunction ContractMultiMint_No_Paymaster(address userAddress, uint[] memory nonces)public returns (bool){\n\t\taddress WhatSubContractToUse = AllowedToUsePaymaster[userAddress];\n\t\tif(WhatSubContractToUse != address(0)){\n\t\t\tPaymaster2(WhatSubContractToUse).PoolContract_Mint_No_Paymaster(nonces);\n\t\t}else{\n\t\t\tdeployNewContract(userAddress);\n\t\t\tzkBitcoin2(allowedToken).multiMint_SameAddress(userAddress, nonces);\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t\n \tfunction External_recieveETH_From_SubContract(address user, uint amount) public{\n\t\taddress WhatSubContractToUse = AllowedToUsePaymaster[user];\n\t\t\n\t\tPaymaster2(WhatSubContractToUse).withdrawETH(amount);\n\t}\n\t\n \tfunction External_recieveERC20_From_SubContract(address user, address token, uint amount) public{\n\t\taddress WhatSubContractToUse = AllowedToUsePaymaster[user];\n\t\t\n\t\tPaymaster2(WhatSubContractToUse).withdrawERC20(token, amount);\n\t}\n\t\n\tfunction External_recieveNFT721_From_SubContract(address user, address token, uint NFT_ID) public{\n\t\n\t\taddress WhatSubContractToUse = AllowedToUsePaymaster[user];\n\t\t\n\t\tPaymaster2(WhatSubContractToUse).withdrawERC721(token, NFT_ID);\n\t\n\t}\n\t\n\tfunction External_recieveNFT115_From_SubContract(address user, address token, uint256 tokenId, uint256 amount, bytes calldata data) public{\n\t\n\t\n\t\taddress WhatSubContractToUse = AllowedToUsePaymaster[user];\n\t\t\n\t\tPaymaster2(WhatSubContractToUse).withdrawERC1155(token, tokenId, amount, data);\n\t\n\t}\n\tfunction External_NumberOfMints(address user) public view returns (uint){\n\t\n\t\n\t\taddress WhatSubContractToUse = AllowedToUsePaymaster[user];\n\t\t\n\t\treturn Paymaster2(WhatSubContractToUse).NumberofMints();\n\t\n\t}\n\t\n\tfunction MultiMint_Paymaster(address MintToAddress, uint[] memory nonces) public returns (bool)\n\t{\n\t\treturn true;\n\t}\n\t\n    receive() external payable {}\n    \n    \n    }\n    \n    \n    \n\n"
    }
  },
  "settings": {
    "compilerVersion": "0.8.17",
    "optimizer": {
      "enabled": true,
      "mode": "3",
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {},
    "zksolc": {
      "version": "1.3.13",
      "compilerSource": "binary",
      "settings": {
        "optimizer": {
          "enabled": true
        }
      }
    }
  }
}